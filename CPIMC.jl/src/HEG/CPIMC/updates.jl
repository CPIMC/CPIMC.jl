const ex_radius = 3 #max Radius for exitation

function move_particle(c::Configuration, e::Ensemble) :: Tuple{Float64, Step}
    free_orbitals = get_non_interacting_orbs_of_set(c, c.occupations)
    if isempty(free_orbitals)
        return 1.0, Step()
    else
        x = rand(get_non_interacting_orbs_of_set(c, c.occupations))
    end
    oe = get_non_interacting_orbs_of_set(c,setdiff!(get_sphere_with_same_spin(x, dk = ex_radius), c.occupations))

    #if there are no empty non interacting orbitals in neighbourhood make no change
    if isempty(oe)
        return 1.0, Step()
    end
    y = rand(oe)
    @assert x != y "same Configuration proposed."

    delta_di = get_change_diagonal_interaction(c, e, T2(y,x), ImgTime(0), ImgTime(1))
    @assert delta_di != Inf
    # weight change
    dw = exp(-(e.β*(get_energy(y)-get_energy(x)) + delta_di))

    # MC Step generated by this update
    Δ = Step(x, y)

    # get orbitals for reverse update
    oe2 = get_non_interacting_orbs_of_set(promote(c,Δ),setdiff!(get_sphere_with_same_spin(y, dk = ex_radius), promote(c,Δ).occupations ))

    occupations(promote(c,Δ).occupations, promote(c,Δ).kinks)

    # quotient of proposal probabilities
    dv = length(oe)/length(oe2)
    @assert (dv*dw) >= 0
    return dv*dw, Δ
end

function add_type_B(c::Configuration, e::Ensemble) :: Tuple{Float64, Step}
    #samplign propability
    prop_prob = 1
    #get first τ
    τ1 = ImgTime(rand())
    #do not allow two kinks at the same time
    while haskey(c.kinks, τ1)
        τ1 = ImgTime(rand())
    end
    occs = occupations(c, τ1)
    orb_c = rand(occs)
    prop_prob *= 1.0/e.N
    orb_d = rand(occs)
    while orb_d == orb_c
        orb_d = rand(occs)
    end
    prop_prob *= 1.0/(e.N-1)
    opportunities_orb_a = setdiff!(get_sphere_with_same_spin(orb_c, dk = ex_radius), occs)
    opportunities_orb_b = setdiff!(get_sphere_with_same_spin(orb_d, dk = ex_radius), occs)
    if isempty(opportunities_orb_a) | isempty(opportunities_orb_b)
        return 1.0, Step()
    end
    orb_a = rand(opportunities_orb_a)
    orb_b = OrbitalHEG((orb_c.vec-orb_a.vec) + orb_d.vec,orb_d.spin)
    @assert !((orb_a == orb_d) | (orb_b == orb_c))
    if (!in(orb_b,opportunities_orb_b) | (orb_a == orb_b))
        return 1.0, Step()
    end

    #We will change the proposal probability after we get τ2


    #get τ2
    borders = get_τ_borders(c, Set([orb_a,orb_b,orb_c,orb_d]),τ1)
    possible_τ2_interval = borders[2]-borders[1]
    if possible_τ2_interval < 0
        possible_τ2_interval += 1
    end
    τ2 = ImgTime(rand()*(possible_τ2_interval) + borders[1])
    if τ2 > 1
        τ2 -= 1
    end
    #do not allow two kinks at the same time
    while haskey(c.kinks, τ2)
        τ2 = ImgTime(rand()*(possible_τ2_interval) + borders[1])
        if τ2 > 1
            τ2 -= 1
        end
    end
    #See which of the two imiginary time point is the "left border of the intervall"
    #If there are no kinks effecting any of the new kinks orbitals then anyone
    #of the two τs can be first τ
    if borders[2] == 1
        if rand() < 0.5
            firstτ = τ1
            lastτ = τ2
        else
            firstτ = τ2
            lastτ = τ1
        end
        prop_prob *= 0.5
    #If there are kinks which τ is firstτ depends on which is the
    #left one inside the given Interval
    elseif τ1 > borders[1]
        if τ2 > borders[1]
            firstτ = min(τ1,τ2)
            lastτ = max(τ1,τ2)
        else
            firstτ = τ1
            lastτ = τ2
        end
    else
        if τ2 < borders[1]
            firstτ = min(τ1,τ2)
            lastτ = max(τ1,τ2)
        else
            firstτ = τ2
            lastτ = τ1
        end
    end
    delta_τ = lastτ - firstτ
    if delta_τ < 0
        delta_τ += 1
    end
    @assert(delta_τ > 0)
    @assert(delta_τ <= 1)


    #We do consider states that differ only threw the order off indices of kinks
    #as different states, that contribute all with the same weight with is already
    #blocked over all permutations (see function “get_abs_offdiagonal_element”),
    #therefore the updates where we end up with the same kinks but start building
    #the kink with a different Excitation will result in a different order off indices
    #and therefore considered a different Update (to compensate that we use a factor ¼
    #in the off diagonal Matrix element contribution) .

    #However we have to consider the different ways off getting to the same
    #update by choosing the imaginary times in a different order.

    #Therefore we modify the proposal_probability in the following way
    occs_τ2 = occupations(c, τ2)
    opportunities_orb_a_τ2 = setdiff!(get_sphere_with_same_spin(orb_c, dk = ex_radius), occs_τ2)
    @assert !isempty(opportunities_orb_a_τ2)
    prop_prob *= (1.0/length(opportunities_orb_a) + 1.0/length(opportunities_orb_a_τ2)) * 1.0/float(possible_τ2_interval)





    #calculate change in diagonal interaction energy
    delta_di = get_change_diagonal_interaction(c, e, T4(orb_a,orb_b,orb_c,orb_d), firstτ, lastτ)

    #change configuration
    # c.kinks[firstτ] = T4(orb_a,orb_b,orb_c,orb_d)
    #shuffle index order of the second kink
    if rand() < 0.5
        if rand() < 0.5
            # swap both
            add_kinks = (firstτ => T4(orb_a,orb_b,orb_c,orb_d),lastτ => T4(orb_d,orb_c,orb_b,orb_a))
        else
            # swap anihilators
            add_kinks = (firstτ => T4(orb_a,orb_b,orb_c,orb_d),lastτ => T4(orb_c,orb_d,orb_b,orb_a))
        end
    else
        if rand() < 0.5
            # swap creators
            add_kinks = (firstτ => T4(orb_a,orb_b,orb_c,orb_d), lastτ => T4(orb_d,orb_c,orb_a,orb_b))
        else
            # swap none
            add_kinks = (firstτ => T4(orb_a,orb_b,orb_c,orb_d), lastτ => T4(orb_c,orb_d,orb_a,orb_b))
        end
    end
    prop_prob *= 1/4

    #Look at wether the new pair of kinks modifies the Occupations at τ = 0
    if firstτ > lastτ
        drop_orbs = Set([orb_c, orb_d])
        add_orbs = Set([orb_a, orb_b])
    else
        drop_orbs = nothing
        add_orbs = Set{basis(c)}()
    end

    # MC step generated by this update
    Δ = Step(drop_orbs, Configuration(add_orbs, add_kinks...))

    # quotient of proposal probabilities
    dv = (1.0/length(get_right_type_B_pairs(promote(c,Δ))))/prop_prob

    # weight factor
    dw = ((e.β)^2) *
            get_abs_offdiagonal_element(e,promote(c,Δ),T4(orb_a,orb_b,orb_c,orb_d))^2 *
            exp(-((delta_τ)*e.β * (get_energy(orb_a) + get_energy(orb_b) -
                get_energy(orb_c) - get_energy(orb_d)) + delta_di))

    occupations(promote(c,Δ).occupations, promote(c,Δ).kinks)

    @assert (dv*dw) >= 0
    @assert (dv*dw) != Inf
    @assert !isnan(dv*dw)
    return dv*dw, Δ
end

function remove_type_B(c::Configuration, e::Ensemble) :: Tuple{Float64, Step}
    if isempty(c.kinks)
        return 1.0, Step()
    end
    opportunities = get_right_type_B_pairs(c)
    if isempty(opportunities)
        return 1.0, Step()
    end
    #If a kink1 is entangeld to the right with the nearest kink, that
    # acts on one of his orbs, in a type-B-way that implies the vice versa case
    # therefor there is no value in distingusihing between left and right entanglement
    τ_kink1, τ_kink2 = rand(get_right_type_B_pairs(c))
    kink1 = τ_kink1 => c.kinks[τ_kink1]
    kink2 = τ_kink2 => c.kinks[τ_kink2]

    if last(kink1).i.spin != last(kink1).k.spin
        return 1.0, Step()
    end
    # if the difference between i and k is larger then ex_radius we can not create the kink and therefore also can't delete it
    if dot(last(kink1).i.vec-last(kink1).k.vec, last(kink1).i.vec-last(kink1).k.vec) > ex_radius^2
        return 1.0, Step()
    end
    prop_prob = 1.0/length(opportunities)

    #change configuration
    # delete!(c.kinks, first(kink1))
    # delete!(c.kinks, first(kink2))


    #see if occupations at τ=0 are modified
    if first(kink1) > first(kink2)
        # change_occupations(c.occupations, last(kink2))
        add_orbs = Set([last(kink2).i, last(kink2).j])
        drop_orbs = Set([last(kink2).k, last(kink2).l])
        delta_τ = first(kink2)-first(kink1) + 1.0
    else
        add_orbs = nothing
        drop_orbs = Set{basis(c)}()
        delta_τ = first(kink2)-first(kink1)
    end

    # MC step generated by this update
    Δ = Step(Configuration(drop_orbs, kink1, kink2), add_orbs)
    @assert(delta_τ > 0)
    @assert(delta_τ <= 1)

    #calculate inverse prop_prob (see  add_type_B)
    ijkl = Set([last(kink1).i, last(kink1).j, last(kink1).k, last(kink1).l])
    borders = get_τ_borders(promote(c,Δ), ijkl ,first(kink1))
    possible_τ2_interval = borders[2]-borders[1]
    if possible_τ2_interval < 0
        possible_τ2_interval = 1 + possible_τ2_interval
    end
    occs_τ_kink1 = occupations(promote(c,Δ), first(kink1))
    occs_τ_kink2 = occupations(promote(c,Δ), first(kink2))
    orb_a = last(kink1).i
    orb_b = last(kink1).j
    orb_c = last(kink1).k
    orb_d = last(kink1).l
    #See how prop_prob changes in the function add_type_B to understand this expression
    inverse_prop_prob = (1/e.N)*(1/(e.N-1)) *
        (1.0/length(setdiff!(get_sphere_with_same_spin(orb_c, dk = ex_radius), occs_τ_kink1))
            + 1/length(setdiff!(get_sphere_with_same_spin(orb_c, dk = ex_radius), occs_τ_kink2))) *
         1.0/float(possible_τ2_interval) * (1/4)
    if borders[2] == 1
        inverse_prop_prob *= 0.5
    end
    # quotient of proposal probabilities
    dv = inverse_prop_prob/prop_prob

    # calculate change in diagonal interaction energy
    delta_di = get_change_diagonal_interaction(promote(c, Δ), e, last(kink1), first(kink1), first(kink2))


    # weight factor
    dw = (1.0/(e.β)^2) *
        (1.0/(get_abs_offdiagonal_element(e,promote(c,Δ),last(kink1)))^2) *
            exp((delta_τ)*e.β * (get_energy(orb_a) +
                 get_energy(orb_b) - get_energy(orb_c) - get_energy(orb_d)) + delta_di)

    occupations(promote(c,Δ).occupations, promote(c,Δ).kinks)

    @assert (dv*dw) >= 0
    @assert (dv*dw) != Inf
    return dv*dw, Δ
end


function change_type_B(c::Configuration, e::Ensemble) :: Tuple{Float64,Step} #This update is redundant wif we have add- and remove-Type-C-Updates
    if isempty(c.kinks)
        return 1.0, Step()
    end

    kink_opportunities = get_right_type_B_pairs(c)
    if isempty(kink_opportunities)
        return 1.0, Step()
    end
    τ1, τ2 = rand(kink_opportunities)
    kink1 = (τ1, c.kinks[τ1])
    kink2 = (τ2, c.kinks[τ2])
    occs = occupations(c, first(kink1))

    opportunities = get_non_interacting_orbs_of_set_in_interval(
                        c,setdiff!(
                            get_sphere_with_same_spin(last(kink1).i, dk = ex_radius
                            ), occs
                        ),first(kink1),first(kink2)
                    )
    delete!(opportunities, last(kink1).k)
    delete!(opportunities, last(kink1).l)
    if isempty(opportunities)
        return 1.0, Step()
    end
    new_orb_i = rand(opportunities)
    new_orb_j = OrbitalHEG(last(kink1).j.vec + last(kink1).i.vec - new_orb_i.vec, last(kink1).j.spin)
    if new_orb_i == new_orb_j
        return 1.0, Step()
    end
    if (!is_non_interacting_in_interval(c,new_orb_j,first(kink1),first(kink2)) |
        in(new_orb_j,occs))
        return 1.0, Step()
    else
        #calculate change in diagonal interaction energy
        delta_di = get_change_diagonal_interaction(c, e, T4(new_orb_i, new_orb_j, last(kink1).i, last(kink1).j), first(kink1), first(kink2))

        #change occupations
        if first(kink1) > first(kink2)
            # change_occupations(c.occupations, T4(new_orb_i, new_orb_j, last(kink1).i, last(kink1).j))
            drop_orbs = Set([last(kink1).i, last(kink1).j])
            add_orbs = Set([new_orb_i, new_orb_j])
            delta_τ = first(kink2)-first(kink1) + 1.0
        else
            add_orbs = Set{basis(c)}()
            drop_orbs = Set{basis(c)}()
            delta_τ = first(kink2)-first(kink1)
        end


        dw = exp(-(e.β*delta_τ*(get_energy(new_orb_i) + get_energy(new_orb_j) -
                                    get_energy(last(kink1).i) - get_energy(last(kink1).j)) + delta_di)) *
            (get_abs_offdiagonal_element(e,c,T4(new_orb_i, new_orb_j, last(kink1).k, last(kink1).l))/
                        get_abs_offdiagonal_element(e,c,last(kink1)))^2

        #change kinks
        # c.kinks[first(kink1)] = T4(new_orb_i, new_orb_j, last(kink1).k, last(kink1).l)
        drop_kinks = (kink1,kink2)
        if rand() <= 0.5
            # c.kinks[first(kink2)] = T4(last(kink2).i, last(kink2).j, new_orb_i, new_orb_j)
            add_kinks = (
                        first(kink1) => T4(new_orb_i, new_orb_j, last(kink1).k, last(kink1).l),
                        first(kink2) => T4(last(kink2).i, last(kink2).j, new_orb_i, new_orb_j)
                        )
        else
            # c.kinks[first(kink2)] = T4(last(kink2).i, last(kink2).j, new_orb_j, new_orb_i)
            add_kinks = (
                        first(kink1) => T4(new_orb_i, new_orb_j, last(kink1).k, last(kink1).l),
                        first(kink2) => T4(last(kink2).i, last(kink2).j, new_orb_j, new_orb_i)
                        )
        end

        # change_occupations(occs, T4(new_orb_i, new_orb_j, last(kink1).i, last(kink1).j))
        # MC Step generated by this update
        Δ = Step(Configuration(drop_orbs, drop_kinks...), Configuration(add_orbs, add_kinks...))

        opportunites_reverse = get_non_interacting_orbs_of_set_in_interval(
                                    promote(c,Δ),setdiff!(
                                        get_sphere_with_same_spin(new_orb_i, dk = ex_radius
                                        ), occs
                                    ),first(kink1),first(kink2)
                                )
        delete!(opportunites_reverse, last(kink1).k)
        delete!(opportunites_reverse, last(kink1).l)

        occupations(promote(c,Δ).occupations, promote(c,Δ).kinks)

        @assert (dw * length(opportunities)/length(opportunites_reverse)) >= 0
        return (dw * length(opportunities)/length(opportunites_reverse)), Δ
    end
end


function add_type_C(c::Configuration, e::Ensemble) :: Tuple{Float64,Step}
    prop_prob = 1.0
    if isempty(c.kinks)
        return 1.0, Step()
    end
    old_kink = rand(c.kinks)
    prop_prob *= 1.0/length(c.kinks)
    occs = occupations(c, first(old_kink))
    prop_prob *= 0.5 #left or right
    if rand() >= 0.5
        #add kink left
        opportunities_new_orb1 = setdiff!(get_sphere_with_same_spin(last(old_kink).k, dk = ex_radius), occs)
        delete!(opportunities_new_orb1, last(old_kink).k)
        delete!(opportunities_new_orb1, last(old_kink).l)
        if isempty(opportunities_new_orb1)
            return 1.0, Step()
        end
        new_orb1 = rand(opportunities_new_orb1)
        prop_prob *= 1.0/length(opportunities_new_orb1)
        new_orb2 = OrbitalHEG(last(old_kink).j.vec + (last(old_kink).i.vec - new_orb1.vec), last(old_kink).l.spin)
        if in(new_orb2, occs) | (new_orb1 == new_orb2)
            return 1.0, Step()
        end
        τ_Intervall = first(old_kink) - first(get_τ_borders(c, Set([last(old_kink).k, last(old_kink).l, new_orb1, new_orb2]), first(old_kink)))

        if τ_Intervall < 0
            τ_Intervall +=1
        end
        τ_new_kink = first(old_kink) - ImgTime(rand()*τ_Intervall)
        if τ_new_kink < 0
            τ_new_kink += 1
            delta_τ = Float64(first(old_kink) - τ_new_kink + 1)
        else
            delta_τ = Float64(first(old_kink) - τ_new_kink)
        end
        @assert τ_Intervall > 0
        #no 2 kinks at same τ
        while haskey(c.kinks, τ_new_kink)
            τ_new_kink = first(old_kink) - ImgTime(rand()*τ_Intervall)
            if τ_new_kink < 0
                τ_new_kink += 1
                delta_τ = Float64(first(old_kink) - τ_new_kink + 1)
            else
                delta_τ = Float64(first(old_kink) - τ_new_kink)
            end
        end

        prop_prob *= 1.0/Float64(τ_Intervall)

        delta_di = get_change_diagonal_interaction(c, e, T4(new_orb1,new_orb2,last(old_kink).k,last(old_kink).l), τ_new_kink, first(old_kink))

        #change_Configuration
        #see if c.occupations change
        if τ_new_kink > first(old_kink)  #new kink was added left of old kink
            # change_occupations(c.occupations, T4(new_orb1,new_orb2,last(old_kink).k,last(old_kink).l))
            drop_orbs = Set([last(old_kink).k,last(old_kink).l])
            add_orbs = Set([new_orb1, new_orb2])
        else
            drop_orbs = Set{basis(c)}()
            add_orbs = Set{basis(c)}()
        end

        # c.kinks[τ_new_kink] = T4(new_orb1, new_orb2, last(old_kink).k, last(old_kink).l)
        # c.kinks[first(old_kink)] = T4(last(old_kink).i, last(old_kink).j, new_orb1, new_orb2)

        prop_prob *= 0.5# shuffle annihilators of the changed kink TODO: is this necessary for ergodicy ?
        if rand() < 0.5
            # shuffle
            add_kinks = (
                        τ_new_kink => T4(new_orb1, new_orb2, last(old_kink).k, last(old_kink).l),
                        first(old_kink) => T4(last(old_kink).i, last(old_kink).j, new_orb2, new_orb1)
                        )
        else
            # do not shuffle
            add_kinks = (
                        τ_new_kink => T4(new_orb1, new_orb2, last(old_kink).k, last(old_kink).l),
                        first(old_kink) => T4(last(old_kink).i, last(old_kink).j, new_orb1, new_orb2)
                        )
        end
        drop_kinks = (old_kink,)

        # MC Step generated by this update
        Δ = Step(Configuration(drop_orbs, drop_kinks...), Configuration(add_orbs, add_kinks...))

        #calculate weight differance
        dw_off_diag = get_abs_offdiagonal_element(e,promote(c,Δ),promote(c,Δ).kinks[τ_new_kink]) * get_abs_offdiagonal_element(e,promote(c,Δ),promote(c,Δ).kinks[first(old_kink)]) /
                                                get_abs_offdiagonal_element(e,promote(c,Δ),last(old_kink))
        dw = e.β * dw_off_diag* exp(-(e.β * delta_τ*(get_energy(new_orb1) + get_energy(new_orb2) -
                                    get_energy(last(old_kink).k) - get_energy(last(old_kink).l)) + delta_di))

        inverse_prop_prob = (1.0/length(get_right_type_C_pairs(promote(c,Δ)))) * 0.5

        @assert !isinf(inverse_prop_prob) "change kink left: inverse_prop_prob = Inf"

        # MOVED THIS TO THE SELECTION OF THE KINKS
        # shuffle annihilators of the changed kink
        # if rand() < 0.5
        #     c.kinks[first(first(old_kink))] = T4(c.kinks[first(first(old_kink))].i, c.kinks[first(first(old_kink))].j,
        #                                                c.kinks[first(first(old_kink))].l, c.kinks[first(first(old_kink))].k)
        # else
        #     nothing
        # end
        # prop_prob *= 0.5
    else
        #add kink right
        opportunities_new_orb1 = setdiff!(get_sphere_with_same_spin(last(old_kink).i, dk = ex_radius), occs)
        delete!(opportunities_new_orb1, last(old_kink).k)
        delete!(opportunities_new_orb1, last(old_kink).l)
        if isempty(opportunities_new_orb1)
            return 1.0, Step()
        end
        new_orb1 = rand(opportunities_new_orb1)
        prop_prob *= 1.0/length(opportunities_new_orb1)
        new_orb2 = OrbitalHEG(last(old_kink).l.vec + (last(old_kink).k.vec - new_orb1.vec), last(old_kink).j.spin)
        if in(new_orb2, occs) | (new_orb1 == new_orb2)
            return 1.0, Step()
        end
        τ_Intervall = last(get_τ_borders(c, Set([
                        last(old_kink).i, last(old_kink).j, new_orb1, new_orb2]),first(old_kink))) -
                        first(old_kink)
        if τ_Intervall < 0
            τ_Intervall +=1
        end
        τ_new_kink = first(old_kink) + ImgTime(rand()*τ_Intervall)
        if τ_new_kink > 1
            τ_new_kink -= 1
            delta_τ = Float64(τ_new_kink - first(old_kink) + 1)
        else
            delta_τ = Float64(τ_new_kink - first(old_kink))
        end

        #no 2 kinks at same τ
        @assert τ_Intervall > 0
        while haskey(c.kinks, τ_new_kink)
            τ_new_kink = first(old_kink) + ImgTime(rand()*τ_Intervall)
            if τ_new_kink > 1
                τ_new_kink -= 1
                delta_τ = Float64(τ_new_kink - first(old_kink) + 1)
            else
                delta_τ = Float64(τ_new_kink - first(old_kink))
            end
        end

        prop_prob *= 1.0/Float64(τ_Intervall)

        delta_di = get_change_diagonal_interaction(c, e, T4(new_orb1,new_orb2,last(old_kink).i,last(old_kink).j), first(old_kink), τ_new_kink)

        #change_Configuration
        #see if c.occupations change
        if τ_new_kink < first(old_kink)  #new kink was added right of old kink
            # change_occupations(c.occupations, T4(new_orb1,new_orb2,last(old_kink).i,last(old_kink).j))
            drop_orbs = Set([last(old_kink).i,last(old_kink).j])
            add_orbs = Set([new_orb1,new_orb2])
        else
            drop_orbs = Set{basis(c)}()
            add_orbs = Set{basis(c)}()
        end


        # c.kinks[τ_new_kink] = T4(last(old_kink).i, last(old_kink).j, new_orb1, new_orb2)
        # c.kinks[first(old_kink)] = T4(new_orb1, new_orb2, last(old_kink).k, last(old_kink).l)

        prop_prob *= 0.5# shuffle creators of the changed kink TODO: is this necessary for ergodicy ?
        if rand() < 0.5
            # shuffle
            add_kinks = (
                        τ_new_kink => T4(last(old_kink).i, last(old_kink).j, new_orb1, new_orb2),
                        first(old_kink) => T4(new_orb2, new_orb1, last(old_kink).k, last(old_kink).l)
                        )
        else
            # do not shuffle
            add_kinks = (
                        τ_new_kink => T4(last(old_kink).i, last(old_kink).j, new_orb1, new_orb2),
                        first(old_kink) => T4(new_orb1, new_orb2, last(old_kink).k, last(old_kink).l)
                        )
        end
        drop_kinks = (old_kink,)

        # MC Step generated by this update
        Δ = Step(Configuration(drop_orbs, drop_kinks...), Configuration(add_orbs, add_kinks...))



        dw_off_diag = get_abs_offdiagonal_element(e,promote(c,Δ),promote(c,Δ).kinks[τ_new_kink]) * get_abs_offdiagonal_element(e,promote(c,Δ),promote(c,Δ).kinks[first(old_kink)]) /
                                                get_abs_offdiagonal_element(e,promote(c,Δ),last(old_kink))

        dw = e.β * dw_off_diag* exp(-(e.β * delta_τ*(get_energy(new_orb1) + get_energy(new_orb2) -
                                    get_energy(last(old_kink).i) - get_energy(last(old_kink).j)) + delta_di))

        inverse_prop_prob = (1.0/length(get_left_type_C_pairs(promote(c,Δ)))) * 0.5

        @assert !isinf(inverse_prop_prob) "change kink right: inverse_prop_prob = Inf"

        # MOVED THIS TO THE SELECTION OF THE KINKS
        #shuffle creators of the changed kink
        # if rand() < 0.5
        #     c.kinks[first(first(old_kink))] = T4(c.kinks[first(first(old_kink))].j, c.kinks[first(first(old_kink))].i,
        #                                                 c.kinks[first(first(old_kink))].k, c.kinks[first(first(old_kink))].l)
        # else
        #     nothing
        # end
        # prop_prob *= 0.5
    end


    #check if sign was changend
    #to calculate the sign change use only the orbitals of the old kink objekt and the new orbs,
    #so swaping of ij or kl in one of the kinks does not effect the signchange
    signum = 1
    if new_orb1.spin != last(old_kink).j.spin
        signum*= -1
    elseif new_orb1.spin != last(old_kink).i.spin
        signum*= 1
    elseif dot((last(old_kink).j.vec - new_orb1.vec),(last(old_kink).j.vec - new_orb1.vec)) >
            dot((last(old_kink).i.vec - new_orb1.vec),(last(old_kink).i.vec - new_orb1.vec))
        signum*= -1
    end
    if new_orb1.spin != last(old_kink).l.spin
        signum*= -1
    elseif new_orb1.spin != last(old_kink).k.spin
        signum*= 1
    elseif dot((last(old_kink).l.vec - new_orb1.vec),(last(old_kink).l.vec - new_orb1.vec)) >
            dot((last(old_kink).k.vec - new_orb1.vec),(last(old_kink).k.vec - new_orb1.vec))
        signum*= -1
    end
    if last(old_kink).i.spin != last(old_kink).l.spin
        signum*= -1
    elseif last(old_kink).i.spin != last(old_kink).k.spin
        signum*= 1
    elseif dot((last(old_kink).i.vec - last(old_kink).l.vec),(last(old_kink).i.vec - last(old_kink).l.vec)) >
            dot((last(old_kink).i.vec - last(old_kink).k.vec),(last(old_kink).i.vec - last(old_kink).k.vec))
        signum*= -1
    end

    """if dot((last(old_kink).j.vec - new_orb1.vec),(last(old_kink).j.vec - new_orb1.vec)) >
            dot((last(old_kink).i.vec - new_orb1.vec),(last(old_kink).i.vec - new_orb1.vec))
        signum*= -1
    end
    if dot((last(old_kink).l.vec - new_orb1.vec),(last(old_kink).l.vec - new_orb1.vec)) >
            dot((last(old_kink).k.vec - new_orb1.vec),(last(old_kink).k.vec - new_orb1.vec))
        signum*= -1
    end
    if dot((last(old_kink).i.vec - last(old_kink).l.vec),(last(old_kink).i.vec - last(old_kink).l.vec)) >
            dot((last(old_kink).i.vec - last(old_kink).k.vec),(last(old_kink).i.vec - last(old_kink).k.vec))
        signum*= -1
    end"""


    # c.sign *= signum# TODO: track sign in Step-like object

    occupations(promote(c,Δ).occupations, promote(c,Δ).kinks)

    @assert(!iszero(prop_prob))
    @assert(!isinf(dw))

    @assert(delta_τ > 0 )
    @assert(!isnan((inverse_prop_prob/prop_prob)*dw))
    return ((inverse_prop_prob/prop_prob)*dw), Δ
end

function remove_type_C(c::Configuration, e::Ensemble) :: Tuple{Float64,Step}
    prop_prob = 0.5
    if rand() > 0.5
        #removed kink left of changed kink
        opportunities = get_right_type_C_pairs(c)
        if isempty(opportunities)
            return 1.0, Step()
        end
        removed_kink_τ, changed_kink_τ = rand(opportunities)
        prop_prob *= 1.0/length(opportunities)

        if c.kinks[removed_kink_τ].i.spin != c.kinks[removed_kink_τ].k.spin
            return 1.0, Step()
        end
        # if the difference between i and k is larger then ex_radius we can not create the kink and therefore also can't delete it
        if dot(c.kinks[removed_kink_τ].i.vec-c.kinks[removed_kink_τ].k.vec,
                    c.kinks[removed_kink_τ].i.vec-c.kinks[removed_kink_τ].k.vec) > (ex_radius^2)
            return 1.0, Step()
        end


        #safe thoose for later
        removed_orb1 = c.kinks[changed_kink_τ].k
        removed_orb2 = c.kinks[changed_kink_τ].l

        #change configuration
        # c.kinks[changed_kink_τ] = T4(c.kinks[changed_kink_τ].i, c.kinks[changed_kink_τ].j, c.kinks[removed_kink_τ].k,c.kinks[removed_kink_τ].l)
        # @assert removed_orb1 != c.kinks[changed_kink_τ].k
        @assert removed_orb1 != c.kinks[removed_kink_τ].k
        add_kinks = (changed_kink_τ => T4(c.kinks[changed_kink_τ].i, c.kinks[changed_kink_τ].j, c.kinks[removed_kink_τ].k,c.kinks[removed_kink_τ].l),)

        #see if c.occupations change
        if removed_kink_τ > changed_kink_τ
            # change_occupations(c.occupations, T4(c.kinks[changed_kink_τ].k,c.kinks[changed_kink_τ].l,removed_orb1,removed_orb2))
            drop_orbs = Set([removed_orb1,removed_orb2])
            add_orbs = Set([c.kinks[removed_kink_τ].k,c.kinks[removed_kink_τ].l])
        else
            drop_orbs = Set{basis(c)}()
            add_orbs = Set{basis(c)}()
        end

        # delete!(c.kinks, removed_kink_τ)
        drop_kinks = (changed_kink_τ => c.kinks[changed_kink_τ], removed_kink_τ => c.kinks[removed_kink_τ])

        # MC Step generated by this update
        Δ = Step(Configuration(drop_orbs, drop_kinks...), Configuration(add_orbs, add_kinks...))

        #calculate reverse_prop_prob
        occs = occupations(promote(c,Δ), changed_kink_τ)
        opportunities_reverse_new_orb1 = setdiff!(get_sphere_with_same_spin(promote(c,Δ).kinks[changed_kink_τ].k, dk = ex_radius), occs)
        delete!(opportunities_reverse_new_orb1, promote(c,Δ).kinks[changed_kink_τ].k)
        delete!(opportunities_reverse_new_orb1, promote(c,Δ).kinks[changed_kink_τ].l)

        τ_Intervall = changed_kink_τ - first(get_τ_borders(promote(c,Δ), Set([removed_orb1, removed_orb2,
                         promote(c,Δ).kinks[changed_kink_τ].k, promote(c,Δ).kinks[changed_kink_τ].l]),changed_kink_τ))


        if τ_Intervall < 0
            τ_Intervall +=1
        end

        inverse_prop_prob = (0.5/length(promote(c,Δ).kinks)) * (1.0/length(opportunities_reverse_new_orb1)) *
                                 (1.0/Float64(τ_Intervall)) * (1.0/2.0)# TODO: (1.0/2.0) = 0.5

        #calculate weight change
        delta_di = get_change_diagonal_interaction(promote(c,Δ), e, T4(removed_orb1,removed_orb2, promote(c,Δ).kinks[changed_kink_τ].k, promote(c,Δ).kinks[changed_kink_τ].l), removed_kink_τ, changed_kink_τ)

        dw_off_diag = get_abs_offdiagonal_element(e,promote(c,Δ),T4(removed_orb1, removed_orb2,  promote(c,Δ).kinks[changed_kink_τ].k, promote(c,Δ).kinks[changed_kink_τ].l)) *
                        get_abs_offdiagonal_element(e,promote(c,Δ),T4(promote(c,Δ).kinks[changed_kink_τ].i, promote(c,Δ).kinks[changed_kink_τ].j, removed_orb1, removed_orb2)) /
                            get_abs_offdiagonal_element(e,promote(c,Δ),promote(c,Δ).kinks[changed_kink_τ])

        delta_τ = Float64(changed_kink_τ - removed_kink_τ)
        if delta_τ < 0
            delta_τ +=1
        end
        dw = (1/e.β)* (1/dw_off_diag) * exp(e.β * delta_τ * (get_energy(removed_orb1) + get_energy(removed_orb2) -
                                    get_energy(promote(c,Δ).kinks[changed_kink_τ].k) - get_energy(promote(c,Δ).kinks[changed_kink_τ].l)) + delta_di)

    else
        #removed kink right of changed kink
        opportunities = get_left_type_C_pairs(c)
        if isempty(opportunities)
            return 1.0, Step()
        end
        removed_kink_τ, changed_kink_τ = rand(opportunities)
        prop_prob *= 1.0/length(opportunities)

        if c.kinks[removed_kink_τ].i.spin != c.kinks[removed_kink_τ].k.spin
            return 1.0, Step()
        end
        # if the difference between i and k is larger then ex_radius we can not create the kink and therefore also can't delete it
        if dot(c.kinks[removed_kink_τ].i.vec-c.kinks[removed_kink_τ].k.vec,
                    c.kinks[removed_kink_τ].i.vec-c.kinks[removed_kink_τ].k.vec) > (ex_radius^2)
            return 1.0, Step()
        end

        #safe thoose for later
        removed_orb1 = c.kinks[changed_kink_τ].i
        removed_orb2 = c.kinks[changed_kink_τ].j


        #change configuration
        # c.kinks[changed_kink_τ] = T4(c.kinks[removed_kink_τ].i, c.kinks[removed_kink_τ].j, c.kinks[changed_kink_τ].k,c.kinks[changed_kink_τ].l)
        add_kinks = (changed_kink_τ => T4(c.kinks[removed_kink_τ].i, c.kinks[removed_kink_τ].j, c.kinks[changed_kink_τ].k,c.kinks[changed_kink_τ].l),)

        #see if c.occupations change
        if removed_kink_τ < changed_kink_τ  #new kink was added right of old kink
            # change_occupations(c.occupations, T4(c.kinks[changed_kink_τ].i,c.kinks[changed_kink_τ].j,removed_orb1,removed_orb2))
            drop_orbs = Set([removed_orb1,removed_orb2])
            add_orbs = Set([c.kinks[removed_kink_τ].i, c.kinks[removed_kink_τ].j])
        else
            drop_orbs = Set{basis(c)}()
            add_orbs = Set{basis(c)}()
        end

        # delete!(c.kinks, removed_kink_τ)
        drop_kinks = (changed_kink_τ => c.kinks[changed_kink_τ], removed_kink_τ => c.kinks[removed_kink_τ])

        # MC Step generated by this update
        Δ = Step(Configuration(drop_orbs, drop_kinks...), Configuration(add_orbs, add_kinks...))

        #calculate reverse_prop_prob
        occs = occupations(promote(c,Δ), changed_kink_τ)
        opportunities_reverse_new_orb1 = setdiff!(get_sphere_with_same_spin(promote(c,Δ).kinks[changed_kink_τ].i, dk = ex_radius), occs)
        delete!(opportunities_reverse_new_orb1, promote(c,Δ).kinks[changed_kink_τ].k)
        delete!(opportunities_reverse_new_orb1, promote(c,Δ).kinks[changed_kink_τ].l)

        τ_Intervall =  last(get_τ_borders(promote(c,Δ), Set([promote(c,Δ).kinks[changed_kink_τ].i, promote(c,Δ).kinks[changed_kink_τ].j,
                                                    removed_orb1, removed_orb2]),changed_kink_τ)) - changed_kink_τ

        if τ_Intervall < 0
            τ_Intervall +=1
        end
        inverse_prop_prob = (0.5/length(promote(c,Δ).kinks)) * (1.0/length(opportunities_reverse_new_orb1)) *
                                 (1.0/Float64(τ_Intervall)) * (1/2)# TODO: (1/2) = 0.5

        #calculate weight change
        delta_di = get_change_diagonal_interaction(promote(c,Δ), e, T4(removed_orb1,removed_orb2, promote(c,Δ).kinks[changed_kink_τ].i,promote(c,Δ).kinks[changed_kink_τ].j), changed_kink_τ, removed_kink_τ)

        dw_off_diag = get_abs_offdiagonal_element(e,promote(c,Δ),T4(removed_orb1, removed_orb2,  promote(c,Δ).kinks[changed_kink_τ].k, promote(c,Δ).kinks[changed_kink_τ].l)) *
                        get_abs_offdiagonal_element(e,promote(c,Δ),T4(promote(c,Δ).kinks[changed_kink_τ].i, promote(c,Δ).kinks[changed_kink_τ].j, removed_orb1, removed_orb2)) /
                            get_abs_offdiagonal_element(e,promote(c,Δ),promote(c,Δ).kinks[changed_kink_τ])

        delta_τ = Float64(removed_kink_τ - changed_kink_τ)
        if delta_τ < 0
            delta_τ +=1
        end
        dw = (1.0/e.β)*(1.0/dw_off_diag) * exp(e.β * delta_τ*(get_energy(removed_orb1) + get_energy(removed_orb2) -
                                    get_energy(promote(c,Δ).kinks[changed_kink_τ].i) - get_energy(promote(c,Δ).kinks[changed_kink_τ].j)) + delta_di)

    end
    #check if sign was changend
    """signum = 1
    if dot((c.kinks[changed_kink_τ].j.vec - removed_orb1.vec),(c.kinks[changed_kink_τ].j.vec - removed_orb1.vec)) >
            dot((c.kinks[changed_kink_τ].i.vec - removed_orb1.vec),(c.kinks[changed_kink_τ].i.vec - removed_orb1.vec))
        signum*= -1
    end
    if dot((c.kinks[changed_kink_τ].l.vec - removed_orb1.vec),(c.kinks[changed_kink_τ].l.vec - removed_orb1.vec)) >
            dot((c.kinks[changed_kink_τ].k.vec - removed_orb1.vec),(c.kinks[changed_kink_τ].k.vec - removed_orb1.vec))
        signum*= -1
    end
    if dot((c.kinks[changed_kink_τ].i.vec -c.kinks[changed_kink_τ].l.vec),(c.kinks[changed_kink_τ].i.vec - c.kinks[changed_kink_τ].l.vec)) >
            dot((c.kinks[changed_kink_τ].i.vec - c.kinks[changed_kink_τ].k.vec),(c.kinks[changed_kink_τ].i.vec - c.kinks[changed_kink_τ].k.vec))
        signum*= -1
    end
    """

    signum = 1
    if removed_orb1.spin != promote(c,Δ).kinks[changed_kink_τ].j.spin
        signum*= -1
    elseif removed_orb1.spin != promote(c,Δ).kinks[changed_kink_τ].i.spin
        signum*= 1
    elseif dot((promote(c,Δ).kinks[changed_kink_τ].j.vec - removed_orb1.vec),(promote(c,Δ).kinks[changed_kink_τ].j.vec - removed_orb1.vec)) >
            dot((promote(c,Δ).kinks[changed_kink_τ].i.vec - removed_orb1.vec),(promote(c,Δ).kinks[changed_kink_τ].i.vec - removed_orb1.vec))
        signum*= -1
    end
    if removed_orb1.spin != promote(c,Δ).kinks[changed_kink_τ].l.spin
        signum*= -1
    elseif removed_orb1.spin != promote(c,Δ).kinks[changed_kink_τ].k.spin
        signum*= 1
    elseif dot((promote(c,Δ).kinks[changed_kink_τ].l.vec - removed_orb1.vec),(promote(c,Δ).kinks[changed_kink_τ].l.vec - removed_orb1.vec)) >
            dot((promote(c,Δ).kinks[changed_kink_τ].k.vec - removed_orb1.vec),(promote(c,Δ).kinks[changed_kink_τ].k.vec - removed_orb1.vec))
        signum*= -1
    end
    if promote(c,Δ).kinks[changed_kink_τ].i.spin != promote(c,Δ).kinks[changed_kink_τ].l.spin
        signum*= -1
    elseif promote(c,Δ).kinks[changed_kink_τ].i.spin != promote(c,Δ).kinks[changed_kink_τ].k.spin
        signum*= 1
    elseif dot((promote(c,Δ).kinks[changed_kink_τ].i.vec - promote(c,Δ).kinks[changed_kink_τ].l.vec),(promote(c,Δ).kinks[changed_kink_τ].i.vec - promote(c,Δ).kinks[changed_kink_τ].l.vec)) >
            dot((promote(c,Δ).kinks[changed_kink_τ].i.vec - promote(c,Δ).kinks[changed_kink_τ].k.vec),(promote(c,Δ).kinks[changed_kink_τ].i.vec - promote(c,Δ).kinks[changed_kink_τ].k.vec))
        signum*= -1
    end
    # c.sign *= signum

    occupations(promote(c,Δ).occupations, promote(c,Δ).kinks)

    @assert(delta_τ > 0 )
    @assert(!isnan((inverse_prop_prob/prop_prob) * dw))
    return ((inverse_prop_prob/prop_prob) * dw), Δ
end





function add_type_D(c::Configuration, e::Ensemble) :: Tuple{Float64,Step}
    prop_prob = 1.0
    if isempty(c.kinks)
        return 1.0, Step()
    end
    old_kink = rand(c.kinks)
    prop_prob *= 1.0/length(c.kinks)
    occs = occupations(c, first(old_kink))
    prop_prob *= 0.5 #left or right
    if rand() >= 0.5
        #add kink left
        opportunities_new_orb1 = intersect!(get_sphere_with_same_spin(last(old_kink).i, dk = ex_radius), occs)
        delete!(opportunities_new_orb1, last(old_kink).i)
        delete!(opportunities_new_orb1, last(old_kink).j)
        if isempty(opportunities_new_orb1)
            return 1.0, Step()
        end
        new_orb1 = rand(opportunities_new_orb1)
        prop_prob *= 1.0/length(opportunities_new_orb1)
        new_orb2 = OrbitalHEG(last(old_kink).k.vec + (last(old_kink).l.vec - new_orb1.vec), last(old_kink).j.spin)
        if !in(new_orb2, occs) | (new_orb1 == new_orb2)
            return 1.0, Step()
        end
        τ_Intervall = first(old_kink) - first(get_τ_borders(c, Set([last(old_kink).i, last(old_kink).j, new_orb1, new_orb2]), first(old_kink)))

        if τ_Intervall < 0
            τ_Intervall +=1
        end
        τ_new_kink = first(old_kink) - ImgTime(rand()*τ_Intervall)
        if τ_new_kink < 0
            τ_new_kink += 1
            delta_τ = Float64(first(old_kink) - τ_new_kink + 1)
        else
            delta_τ = Float64(first(old_kink) - τ_new_kink)
        end
        @assert τ_Intervall > 0
        #no 2 kinks at same τ
        while haskey(c.kinks, τ_new_kink)
            τ_new_kink = first(old_kink) - ImgTime(rand()*τ_Intervall)
            if τ_new_kink < 0
                τ_new_kink += 1
                delta_τ = Float64(first(old_kink) - τ_new_kink + 1)
            else
                delta_τ = Float64(first(old_kink) - τ_new_kink)
            end
        end

        prop_prob *= 1.0/Float64(τ_Intervall)

        delta_di = get_change_diagonal_interaction(c, e, T4(last(old_kink).i,last(old_kink).j, new_orb1, new_orb2), τ_new_kink, first(old_kink))

        #change_Configuration
        #see if c.occupations change
        if τ_new_kink > first(old_kink)  #new kink was added left of old kink
            # change_occupations(c.occupations, T4(last(old_kink).i,last(old_kink).j, new_orb1, new_orb2))
            drop_orbs = Set([new_orb1, new_orb2])
            add_orbs = Set([last(old_kink).i,last(old_kink).j])
        else
            drop_orbs = Set{basis(c)}()
            add_orbs = Set{basis(c)}()
        end

        # c.kinks[τ_new_kink] = T4(last(old_kink).i, last(old_kink).j,new_orb1, new_orb2)
        # c.kinks[first(old_kink)] = T4(new_orb1, new_orb2, last(old_kink).k, last(old_kink).l)

        prop_prob *= 0.5#shuffle creators (!) of the changed kink TODO: is this necessary for ergodicy ?
        if rand() < 0.5
            # shuffle
            add_kinks = (
                        τ_new_kink => T4(last(old_kink).i, last(old_kink).j,new_orb1, new_orb2),
                        first(old_kink) => T4(new_orb2, new_orb1, last(old_kink).k, last(old_kink).l)
                        )
        else
            # do not shuffle
            add_kinks = (
                        τ_new_kink => T4(last(old_kink).i, last(old_kink).j,new_orb1, new_orb2),
                        first(old_kink) => T4(new_orb1, new_orb2, last(old_kink).k, last(old_kink).l)
                        )
        end
        drop_kinks = (old_kink,)

        # MC Step generated by this update
        Δ = Step(Configuration(drop_orbs, drop_kinks...), Configuration(add_orbs, add_kinks...))

        #calculate weight differance
        dw_off_diag = get_abs_offdiagonal_element(e,promote(c,Δ),promote(c,Δ).kinks[τ_new_kink]) * get_abs_offdiagonal_element(e,promote(c,Δ),promote(c,Δ).kinks[first(old_kink)]) /
                                                get_abs_offdiagonal_element(e,promote(c,Δ),last(old_kink))
        dw = e.β * dw_off_diag* exp(-(e.β * delta_τ*(get_energy(last(old_kink).i) + get_energy(last(old_kink).j)-
                                                         get_energy(new_orb1) - get_energy(new_orb2)) + delta_di))

        inverse_prop_prob = (1.0/length(get_right_type_D_pairs(promote(c,Δ)))) * 0.5

        # MOVED THIS TO THE SELECTION OF THE KINKS
        #shuffle annihilators of the changed kink TODO: creators are shuffled, not annihilators
        # if rand() < 0.5
        #     c.kinks[first(first(old_kink))] = T4(c.kinks[first(first(old_kink))].j, c.kinks[first(first(old_kink))].i,
        #                                                c.kinks[first(first(old_kink))].k, c.kinks[first(first(old_kink))].l)
        # else
        #     nothing
        # end
        # prop_prob *= 0.5
    else
        #add kink right
        opportunities_new_orb1 = intersect!(get_sphere_with_same_spin(last(old_kink).k, dk = ex_radius), occs)
        delete!(opportunities_new_orb1, last(old_kink).i)
        delete!(opportunities_new_orb1, last(old_kink).j)
        if isempty(opportunities_new_orb1)
            return 1.0, Step()
        end
        new_orb1 = rand(opportunities_new_orb1)
        prop_prob *= 1.0/length(opportunities_new_orb1)
        new_orb2 = OrbitalHEG(last(old_kink).i.vec + (last(old_kink).j.vec - new_orb1.vec), last(old_kink).l.spin)
        if !in(new_orb2, occs) | (new_orb1 == new_orb2)
            return 1.0, Step()
        end
        τ_Intervall = last(get_τ_borders(c, Set([
                        last(old_kink).k, last(old_kink).l, new_orb1, new_orb2]),first(old_kink))) -
                        first(old_kink)
        if τ_Intervall < 0
            τ_Intervall +=1
        end
        τ_new_kink = first(old_kink) + ImgTime(rand()*τ_Intervall)
        if τ_new_kink > 1
            τ_new_kink -= 1
            delta_τ = Float64(τ_new_kink - first(old_kink) + 1)
        else
            delta_τ = Float64(τ_new_kink - first(old_kink))
        end

        #no 2 kinks at same τ
        @assert τ_Intervall > 0
        while haskey(c.kinks, τ_new_kink)
            τ_new_kink = first(old_kink) + ImgTime(rand()*τ_Intervall)
            if τ_new_kink > 1
                τ_new_kink -= 1
                delta_τ = Float64(τ_new_kink - first(old_kink) + 1)
            else
                delta_τ = Float64(τ_new_kink - first(old_kink))
            end
        end

        prop_prob *= 1.0/Float64(τ_Intervall)

        delta_di = get_change_diagonal_interaction(c, e, T4(last(old_kink).k, last(old_kink).l,new_orb1,new_orb2), first(old_kink), τ_new_kink)

        #change_Configuration
        #see if c.occupations change
        if τ_new_kink < first(old_kink)  #new kink was added right of old kink
            # change_occupations(c.occupations, T4(last(old_kink).k, last(old_kink).l,new_orb1,new_orb2))
            drop_orbs = Set([new_orb1,new_orb2])
            add_orbs = Set([last(old_kink).k, last(old_kink).l])
        else
            drop_orbs = Set{basis(c)}()
            add_orbs = Set{basis(c)}()
        end

        # c.kinks[τ_new_kink] = T4(new_orb1, new_orb2, last(old_kink).k, last(old_kink).l)
        # c.kinks[first(old_kink)] = T4(last(old_kink).i, last(old_kink).j, new_orb1, new_orb2)

        prop_prob *= 0.5#shuffle annihilators (!) of the changed kink TODO: is this necessary for ergodicy ?
        if rand() < 0.5
            # shuffle
            add_kinks = (
                        τ_new_kink => T4(new_orb1, new_orb2, last(old_kink).k, last(old_kink).l),
                        first(old_kink) => T4(last(old_kink).i, last(old_kink).j, new_orb2, new_orb1)
                        )
        else
            # do note shuffle
            add_kinks = (
                        τ_new_kink => T4(new_orb1, new_orb2, last(old_kink).k, last(old_kink).l),
                        first(old_kink) => T4(last(old_kink).i, last(old_kink).j, new_orb1, new_orb2)
                        )
        end
        drop_kinks = (old_kink,)

        # MC Step generated by this update
        Δ = Step(Configuration(drop_orbs, drop_kinks...), Configuration(add_orbs, add_kinks...))

        dw_off_diag = get_abs_offdiagonal_element(e,promote(c,Δ),promote(c,Δ).kinks[τ_new_kink]) * get_abs_offdiagonal_element(e,promote(c,Δ),promote(c,Δ).kinks[first(old_kink)]) /
                                                get_abs_offdiagonal_element(e,promote(c,Δ),last(old_kink))

        dw = e.β * dw_off_diag* exp(-(e.β * delta_τ*(get_energy(last(old_kink).k) + get_energy(last(old_kink).l) -
                                                         get_energy(new_orb1) - get_energy(new_orb2)) + delta_di))

        inverse_prop_prob = (1.0/length(get_left_type_D_pairs(promote(c,Δ)))) * 0.5


        # MOVED THIS TO THE SELECTION OF THE KINKS
        #shuffle creators of the changed kink TODO: annihilators are shuffled, not creators
        # if rand() < 0.5
        #     c.kinks[first(first(old_kink))] = T4(c.kinks[first(first(old_kink))].i, c.kinks[first(first(old_kink))].j,
        #                                                 c.kinks[first(first(old_kink))].l, c.kinks[first(first(old_kink))].k)
        # else
        #     nothing
        # end
        # prop_prob *= 0.5
    end


    #check if sign was changend
    signum = 1
    if new_orb1.spin != last(old_kink).j.spin
        signum*= -1
    elseif new_orb1.spin != last(old_kink).i.spin
        signum*= 1
    elseif dot((last(old_kink).j.vec - new_orb1.vec),(last(old_kink).j.vec - new_orb1.vec)) >
            dot((last(old_kink).i.vec - new_orb1.vec),(last(old_kink).i.vec - new_orb1.vec))
        signum*= -1
    end
    if new_orb1.spin != last(old_kink).l.spin
        signum*= -1
    elseif new_orb1.spin != last(old_kink).k.spin
        signum*= 1
    elseif dot((last(old_kink).l.vec - new_orb1.vec),(last(old_kink).l.vec - new_orb1.vec)) >
            dot((last(old_kink).k.vec - new_orb1.vec),(last(old_kink).k.vec - new_orb1.vec))
        signum*= -1
    end
    if last(old_kink).i.spin != last(old_kink).l.spin
        signum*= -1
    elseif last(old_kink).i.spin != last(old_kink).k.spin
        signum*= 1
    elseif dot((last(old_kink).i.vec - last(old_kink).l.vec),(last(old_kink).i.vec - last(old_kink).l.vec)) >
            dot((last(old_kink).i.vec - last(old_kink).k.vec),(last(old_kink).i.vec - last(old_kink).k.vec))
        signum*= -1
    end

    # c.sign *= signum# TODO: this sign-change must be kept in a Step-like object in order to be reversible

    occupations(promote(c,Δ).occupations, promote(c,Δ).kinks)

    @assert(delta_τ > 0 )
    @assert(!isnan((inverse_prop_prob/prop_prob)*dw))
    return ((inverse_prop_prob/prop_prob)*dw), Δ
end

function remove_type_D(c::Configuration, e::Ensemble) :: Tuple{Float64,Step}
    prop_prob = 0.5
    if rand() > 0.5
        #removed kink left of changed kink
        opportunities = get_right_type_D_pairs(c)
        if isempty(opportunities)
            return 1.0, Step()
        end
        removed_kink_τ, changed_kink_τ = rand(opportunities)
        prop_prob *= 1.0/length(opportunities)

        if c.kinks[removed_kink_τ].i.spin != c.kinks[removed_kink_τ].k.spin
            return 1.0, Step()
        end
        # if the difference between i and k is larger then ex_radius we can not create the kink and therefore also can't delete it
        if dot(c.kinks[removed_kink_τ].i.vec-c.kinks[removed_kink_τ].k.vec,
                    c.kinks[removed_kink_τ].i.vec-c.kinks[removed_kink_τ].k.vec) > (ex_radius^2)
            return 1.0, Step()
        end


        #safe those for later
        removed_orb1 = c.kinks[removed_kink_τ].k
        removed_orb2 = c.kinks[removed_kink_τ].l

        #change configuration
        # c.kinks[changed_kink_τ] = T4(c.kinks[removed_kink_τ].i,c.kinks[removed_kink_τ].j,c.kinks[changed_kink_τ].k,c.kinks[changed_kink_τ].l)
        # @assert removed_orb1 != c.kinks[changed_kink_τ].k
        @assert removed_orb1 != c.kinks[changed_kink_τ].k
        add_kinks = (changed_kink_τ => T4(c.kinks[removed_kink_τ].i,c.kinks[removed_kink_τ].j,c.kinks[changed_kink_τ].k,c.kinks[changed_kink_τ].l),)

        #see if c.occupations change
        if removed_kink_τ > changed_kink_τ
            # change_occupations(c.occupations, T4(removed_orb1,removed_orb2, c.kinks[changed_kink_τ].i,c.kinks[changed_kink_τ].j))
            drop_orbs = Set([c.kinks[removed_kink_τ].i,c.kinks[removed_kink_τ].j])
            add_orbs = Set([removed_orb1,removed_orb2])
        else
            drop_orbs = Set{basis(c)}()
            add_orbs = Set{basis(c)}()
        end


        # delete!(c.kinks, removed_kink_τ)
        drop_kinks = (removed_kink_τ => c.kinks[removed_kink_τ], changed_kink_τ => c.kinks[changed_kink_τ], )

        # MC Step generated by this update
        Δ = Step(Configuration(drop_orbs, drop_kinks...), Configuration(add_orbs, add_kinks...))

        #calculate reverse_prop_prob
        occs = occupations(promote(c,Δ), changed_kink_τ)
        opportunities_reverse_new_orb1 = intersect!(get_sphere_with_same_spin(promote(c,Δ).kinks[changed_kink_τ].i, dk = ex_radius), occs)
        delete!(opportunities_reverse_new_orb1, promote(c,Δ).kinks[changed_kink_τ].i)
        delete!(opportunities_reverse_new_orb1, promote(c,Δ).kinks[changed_kink_τ].j)
        @assert(in(removed_orb1,opportunities_reverse_new_orb1))
        τ_Intervall = changed_kink_τ - first(get_τ_borders(promote(c,Δ), Set([removed_orb1, removed_orb2,
                         promote(c,Δ).kinks[changed_kink_τ].i, promote(c,Δ).kinks[changed_kink_τ].j]),changed_kink_τ))


        if τ_Intervall < 0
            τ_Intervall +=1
        end

        inverse_prop_prob = (0.5/length(promote(c,Δ).kinks)) * (1.0/length(opportunities_reverse_new_orb1)) *
                                 (1.0/Float64(τ_Intervall)) * (1/2)# TODO: (1/2) = 0.5

        #calculate weight change
        delta_di = get_change_diagonal_interaction(promote(c,Δ), e, T4(promote(c,Δ).kinks[changed_kink_τ].i,promote(c,Δ).kinks[changed_kink_τ].j, removed_orb1,removed_orb2), removed_kink_τ, changed_kink_τ)

        dw_off_diag = get_abs_offdiagonal_element(e,promote(c,Δ),T4(removed_orb1, removed_orb2, promote(c,Δ).kinks[changed_kink_τ].k, promote(c,Δ).kinks[changed_kink_τ].l)) *
                        get_abs_offdiagonal_element(e,promote(c,Δ),T4(promote(c,Δ).kinks[changed_kink_τ].i, promote(c,Δ).kinks[changed_kink_τ].j, removed_orb1, removed_orb2)) /
                            get_abs_offdiagonal_element(e,promote(c,Δ),promote(c,Δ).kinks[changed_kink_τ])

        delta_τ = Float64(changed_kink_τ - removed_kink_τ)
        if delta_τ < 0
            delta_τ +=1
        end
        dw = (1.0/e.β)* (1.0/dw_off_diag) * exp(e.β * delta_τ * (get_energy(promote(c,Δ).kinks[changed_kink_τ].i) + get_energy(promote(c,Δ).kinks[changed_kink_τ].j) -
                                                                    get_energy(removed_orb1) - get_energy(removed_orb2)) + delta_di)

    else
        #removed kink right of changed kink
        opportunities = get_left_type_D_pairs(c)
        if isempty(opportunities)
            return 1.0, Step()
        end
        removed_kink_τ, changed_kink_τ = rand(opportunities)
        prop_prob *= 1.0/length(opportunities)

        if c.kinks[removed_kink_τ].i.spin != c.kinks[removed_kink_τ].k.spin
            return 1.0, Step()
        end
        # if the difference between i and k is larger then ex_radius we can not create the kink and therefore also can't delete it
        if dot(c.kinks[removed_kink_τ].i.vec-c.kinks[removed_kink_τ].k.vec,
                    c.kinks[removed_kink_τ].i.vec-c.kinks[removed_kink_τ].k.vec) > (ex_radius^2)
            return 1.0, Step()
        end

        #safe thoose for later
        removed_orb1 = c.kinks[removed_kink_τ].i
        removed_orb2 = c.kinks[removed_kink_τ].j


        #change configuration
        # c.kinks[changed_kink_τ] = T4(c.kinks[changed_kink_τ].i,c.kinks[changed_kink_τ].j,c.kinks[removed_kink_τ].k,c.kinks[removed_kink_τ].l)
        add_kinks = (changed_kink_τ => T4(c.kinks[changed_kink_τ].i,c.kinks[changed_kink_τ].j,c.kinks[removed_kink_τ].k,c.kinks[removed_kink_τ].l),)

        #see if c.occupations change
        if removed_kink_τ < changed_kink_τ  #new kink was added right of old kink
            # change_occupations(c.occupations, T4(removed_orb1, removed_orb2, c.kinks[changed_kink_τ].k,c.kinks[changed_kink_τ].l))
            drop_orbs = Set([c.kinks[removed_kink_τ].k,c.kinks[removed_kink_τ].l])
            add_orbs = Set([removed_orb1, removed_orb2])
        else
            drop_orbs = Set{basis(c)}()
            add_orbs = Set{basis(c)}()
        end

        # delete!(c.kinks, removed_kink_τ)
        drop_kinks = (removed_kink_τ => c.kinks[removed_kink_τ], changed_kink_τ => c.kinks[changed_kink_τ])

        # MC Step generated by this update
        Δ = Step(Configuration(drop_orbs, drop_kinks...), Configuration(add_orbs, add_kinks...))

        #calculate reverse_prop_prob
        occs = occupations(promote(c,Δ), changed_kink_τ)
        opportunities_reverse_new_orb1 = intersect!(get_sphere_with_same_spin(promote(c,Δ).kinks[changed_kink_τ].k, dk = ex_radius), occs)
        delete!(opportunities_reverse_new_orb1, promote(c,Δ).kinks[changed_kink_τ].i)
        delete!(opportunities_reverse_new_orb1, promote(c,Δ).kinks[changed_kink_τ].j)
        @assert(in(removed_orb1,opportunities_reverse_new_orb1))
        τ_Intervall =  last(get_τ_borders(promote(c,Δ), Set([promote(c,Δ).kinks[changed_kink_τ].k, promote(c,Δ).kinks[changed_kink_τ].l,
                                                    removed_orb1, removed_orb2]),changed_kink_τ)) - changed_kink_τ

        if τ_Intervall < 0
            τ_Intervall +=1
        end
        inverse_prop_prob = (0.5/length(promote(c,Δ).kinks)) * (1.0/length(opportunities_reverse_new_orb1)) *
                                 (1.0/Float64(τ_Intervall)) * (1/2)# TODO: (1/2) = 0.5

        #calculate weight change
        delta_di = get_change_diagonal_interaction(promote(c,Δ), e, T4(promote(c,Δ).kinks[changed_kink_τ].k,promote(c,Δ).kinks[changed_kink_τ].l, removed_orb1,removed_orb2), changed_kink_τ, removed_kink_τ)

        dw_off_diag = get_abs_offdiagonal_element(e,promote(c,Δ),T4(removed_orb1, removed_orb2,  promote(c,Δ).kinks[changed_kink_τ].k, promote(c,Δ).kinks[changed_kink_τ].l)) *
                        get_abs_offdiagonal_element(e,promote(c,Δ),T4(promote(c,Δ).kinks[changed_kink_τ].i, promote(c,Δ).kinks[changed_kink_τ].j, removed_orb1, removed_orb2)) /
                            get_abs_offdiagonal_element(e,promote(c,Δ),promote(c,Δ).kinks[changed_kink_τ])

        delta_τ = Float64(removed_kink_τ - changed_kink_τ)
        if delta_τ < 0
            delta_τ +=1
        end
        dw = (1.0/e.β)*(1.0/dw_off_diag) * exp(e.β * delta_τ*(get_energy(promote(c,Δ).kinks[changed_kink_τ].k) + get_energy(promote(c,Δ).kinks[changed_kink_τ].l) -
                                                            get_energy(removed_orb1) - get_energy(removed_orb2)) + delta_di)

    end
    #check if sign was changend
    """signum = 1
    if dot((c.kinks[changed_kink_τ].j.vec - removed_orb1.vec),(c.kinks[changed_kink_τ].j.vec - removed_orb1.vec)) >
            dot((c.kinks[changed_kink_τ].i.vec - removed_orb1.vec),(c.kinks[changed_kink_τ].i.vec - removed_orb1.vec))
        signum*= -1
    end
    if dot((c.kinks[changed_kink_τ].l.vec - removed_orb1.vec),(c.kinks[changed_kink_τ].l.vec - removed_orb1.vec)) >
            dot((c.kinks[changed_kink_τ].k.vec - removed_orb1.vec),(c.kinks[changed_kink_τ].k.vec - removed_orb1.vec))
        signum*= -1
    end
    if dot((c.kinks[changed_kink_τ].i.vec -c.kinks[changed_kink_τ].l.vec),(c.kinks[changed_kink_τ].i.vec - c.kinks[changed_kink_τ].l.vec)) >
            dot((c.kinks[changed_kink_τ].i.vec - c.kinks[changed_kink_τ].k.vec),(c.kinks[changed_kink_τ].i.vec - c.kinks[changed_kink_τ].k.vec))
        signum*= -1
    end"""

    signum = 1
    if removed_orb1.spin != promote(c,Δ).kinks[changed_kink_τ].j.spin
        signum*= -1
    elseif removed_orb1.spin != promote(c,Δ).kinks[changed_kink_τ].i.spin
        signum*= 1
    elseif dot((promote(c,Δ).kinks[changed_kink_τ].j.vec - removed_orb1.vec),(promote(c,Δ).kinks[changed_kink_τ].j.vec - removed_orb1.vec)) >
            dot((promote(c,Δ).kinks[changed_kink_τ].i.vec - removed_orb1.vec),(promote(c,Δ).kinks[changed_kink_τ].i.vec - removed_orb1.vec))
        signum*= -1
    end
    if removed_orb1.spin != promote(c,Δ).kinks[changed_kink_τ].l.spin
        signum*= -1
    elseif removed_orb1.spin != promote(c,Δ).kinks[changed_kink_τ].k.spin
        signum*= 1
    elseif dot((promote(c,Δ).kinks[changed_kink_τ].l.vec - removed_orb1.vec),(promote(c,Δ).kinks[changed_kink_τ].l.vec - removed_orb1.vec)) >
            dot((promote(c,Δ).kinks[changed_kink_τ].k.vec - removed_orb1.vec),(promote(c,Δ).kinks[changed_kink_τ].k.vec - removed_orb1.vec))
        signum*= -1
    end
    if promote(c,Δ).kinks[changed_kink_τ].i.spin != promote(c,Δ).kinks[changed_kink_τ].l.spin
        signum*= -1
    elseif promote(c,Δ).kinks[changed_kink_τ].i.spin != promote(c,Δ).kinks[changed_kink_τ].k.spin
        signum*= 1
    elseif dot((promote(c,Δ).kinks[changed_kink_τ].i.vec - promote(c,Δ).kinks[changed_kink_τ].l.vec),(promote(c,Δ).kinks[changed_kink_τ].i.vec - promote(c,Δ).kinks[changed_kink_τ].l.vec)) >
            dot((promote(c,Δ).kinks[changed_kink_τ].i.vec - promote(c,Δ).kinks[changed_kink_τ].k.vec),(promote(c,Δ).kinks[changed_kink_τ].i.vec - promote(c,Δ).kinks[changed_kink_τ].k.vec))
        signum*= -1
    end
    # c.sign *= signum# TODO: this sign-change must be kept in a Step-like object in order to be reversible

    occupations(promote(c,Δ).occupations, promote(c,Δ).kinks)
    @assert(dw != Inf)
    @assert(delta_τ > 0 )
    @assert(!isnan((inverse_prop_prob/prop_prob) * dw))

    occupations(promote(c,Δ).occupations, promote(c,Δ).kinks)

    return ((inverse_prop_prob/prop_prob) * dw), Δ
end



function add_type_E(c::Configuration, e::Ensemble) :: Tuple{Float64,Step}
    #After the updates the i and l komponents of both kinks will contain the old kink, wile the j and k components contain the old orbitals
    prop_prob = 1.0
    if isempty(c.kinks)
        return 1.0, Step()
    end
    old_kink = rand(c.kinks)
    prop_prob *= 1.0/length(c.kinks)
    occs = occupations(c, first(old_kink))
    prop_prob *= 0.5 #left or right
    if rand() >= 0.5
        #add kink left
        #now choose orbitals of the old kinks that shell also be part of the new kink
        prop_prob *= 0.5
        #choose exitation to of old kink to happen in first kink after update and exitation to happen second
        if rand() > 0.5
            new_kink_old_creator = last(old_kink).i
            changed_kink_old_creator = last(old_kink).j
        else
            new_kink_old_creator = last(old_kink).j
            changed_kink_old_creator = last(old_kink).i
        end
        prop_prob *= 0.5
        if rand() > 0.5
            new_kink_old_annihilator = last(old_kink).k
            changed_kink_old_annihilator = last(old_kink).l
        else
            new_kink_old_annihilator = last(old_kink).l
            changed_kink_old_annihilator = last(old_kink).k
        end
        #find occupied orb for creation of Type_E
        opportunities_new_kink_new_annihilator = intersect!(union!(get_sphere_with_same_spin(new_kink_old_creator, dk = ex_radius),
                                                                        get_sphere_with_same_spin(OrbitalHEG(new_kink_old_creator.vec, -new_kink_old_annihilator.spin), dk = ex_radius)), occs)
        delete!(opportunities_new_kink_new_annihilator, last(old_kink).i)
        delete!(opportunities_new_kink_new_annihilator, last(old_kink).j)
        if isempty(opportunities_new_kink_new_annihilator)
            return 1.0, Step()
        end
        new_kink_new_annihilator = rand(opportunities_new_kink_new_annihilator)
        prop_prob *= 1.0/length(opportunities_new_kink_new_annihilator)
        #calculate new creator
        if new_kink_new_annihilator.spin == new_kink_old_annihilator.spin
            new_kink_new_creator = OrbitalHEG(new_kink_old_annihilator.vec + (new_kink_new_annihilator.vec - new_kink_old_creator.vec), new_kink_old_creator.spin)
        else
            new_kink_new_creator = OrbitalHEG(new_kink_old_annihilator.vec + (new_kink_new_annihilator.vec - new_kink_old_creator.vec), -1 * new_kink_old_creator.spin)
        end
        if (in(new_kink_new_creator, occs) | (new_kink_new_creator == last(old_kink).k) | (new_kink_new_creator == last(old_kink).l))
            return 1.0, Step()
        end

        τ_Intervall = first(old_kink) - first(get_τ_borders(c, Set([new_kink_old_creator, new_kink_new_creator, new_kink_new_annihilator, new_kink_old_annihilator]), first(old_kink)))

        if τ_Intervall < 0
            τ_Intervall +=1
        end
        τ_new_kink = first(old_kink) - ImgTime(rand()*τ_Intervall)
        if τ_new_kink < 0
            τ_new_kink += 1
            delta_τ = Float64(first(old_kink) - τ_new_kink + 1)
        else
            delta_τ = Float64(first(old_kink) - τ_new_kink)
        end
        @assert τ_Intervall > 0
        #no 2 kinks at same τ
        while haskey(c.kinks, τ_new_kink)
            τ_new_kink = first(old_kink) - ImgTime(rand()*τ_Intervall)
            if τ_new_kink < 0
                τ_new_kink += 1
                delta_τ = Float64(first(old_kink) - τ_new_kink + 1)
            else
                delta_τ = Float64(first(old_kink) - τ_new_kink)
            end
        end

        prop_prob *= 1.0/Float64(τ_Intervall)

        delta_di = get_change_diagonal_interaction(c, e, T4(new_kink_old_creator,new_kink_new_creator, new_kink_new_annihilator, new_kink_old_annihilator), τ_new_kink, first(old_kink))

        #change_Configuration
        #see if c.occupations change
        if τ_new_kink > first(old_kink)  #consider that new kink was added left of old kink
            @assert (!in(new_kink_new_creator, c.occupations))
            # change_occupations(c.occupations, T4(new_kink_old_creator,new_kink_new_creator, new_kink_new_annihilator, new_kink_old_annihilator))
            drop_orbs = Set([new_kink_new_annihilator, new_kink_old_annihilator])
            add_orbs = Set([new_kink_old_creator,new_kink_new_creator])
        else
            drop_orbs = Set{basis(c)}()
            add_orbs = Set{basis(c)}()
        end

        # c.kinks[τ_new_kink] = T4(new_kink_old_creator, new_kink_new_creator, new_kink_new_annihilator, new_kink_old_annihilator)
        # c.kinks[first(old_kink)] = T4(changed_kink_old_creator, new_kink_new_annihilator, new_kink_new_creator, changed_kink_old_annihilator)

        #shuffle Indices TODO: is this necessary for ergodicy ?
        #shuffle changed kink
        prop_prob *= 1.0/16.0
        if rand() < 0.5
            if rand() < 0.5
                # shuffle both
                # c.kinks[first(old_kink)] = T4(c.kinks[first(old_kink)].j, c.kinks[first(old_kink)].i,c.kinks[first(old_kink)].l, c.kinks[first(old_kink)].k)
                add_kink1 = first(old_kink) => T4(new_kink_new_annihilator, changed_kink_old_creator, changed_kink_old_annihilator, new_kink_new_creator)
            else
                # shuffle creators
                # c.kinks[first(old_kink)] = T4(c.kinks[first(old_kink)].i, c.kinks[first(old_kink)].j,c.kinks[first(old_kink)].l, c.kinks[first(old_kink)].k)
                add_kink1 = first(old_kink) => T4(new_kink_new_annihilator, changed_kink_old_creator, new_kink_new_creator, changed_kink_old_annihilator)
            end
        else
            if rand() < 0.5
                # shuffle annihilators
                # c.kinks[first(old_kink)] = T4(c.kinks[first(old_kink)].j, c.kinks[first(old_kink)].i,c.kinks[first(old_kink)].k, c.kinks[first(old_kink)].l)
                add_kink1 = first(old_kink) => T4(changed_kink_old_creator, new_kink_new_annihilator, changed_kink_old_annihilator, new_kink_new_creator)
            else
                # do not shuffle
                # c.kinks[first(old_kink)] = T4(c.kinks[first(old_kink)].i, c.kinks[first(old_kink)].j,c.kinks[first(old_kink)].k, c.kinks[first(old_kink)].l)
                add_kink1 = first(old_kink) => T4(changed_kink_old_creator, new_kink_new_annihilator, new_kink_new_creator, changed_kink_old_annihilator)
            end
        end
        #shuffle new kink
        if rand() < 0.5
            if rand() < 0.5
                # shuffle both
                # c.kinks[τ_new_kink] = T4(c.kinks[τ_new_kink].j, c.kinks[τ_new_kink].i,c.kinks[τ_new_kink].l, c.kinks[τ_new_kink].k)
                add_kink2 = τ_new_kink => T4(new_kink_new_creator, new_kink_old_creator, new_kink_old_annihilator, new_kink_new_annihilator)
            else
                # shuffle annihilator
                # c.kinks[τ_new_kink] = T4(c.kinks[τ_new_kink].i, c.kinks[τ_new_kink].j,c.kinks[τ_new_kink].l, c.kinks[τ_new_kink].k)
                add_kink2 = τ_new_kink => T4(new_kink_old_creator, new_kink_new_creator, new_kink_old_annihilator, new_kink_new_annihilator)
            end
        else
            if rand() < 0.5
                # shuffle creators
                # c.kinks[τ_new_kink] = T4(c.kinks[τ_new_kink].j, c.kinks[τ_new_kink].i,c.kinks[τ_new_kink].k, c.kinks[τ_new_kink].l)
                add_kink2 = τ_new_kink => T4(new_kink_new_creator, new_kink_old_creator, new_kink_new_annihilator, new_kink_old_annihilator)
            else
                # do not shuffle
                # c.kinks[τ_new_kink] = T4(c.kinks[τ_new_kink].i, c.kinks[τ_new_kink].j,c.kinks[τ_new_kink].k, c.kinks[τ_new_kink].l)
                add_kink2 = τ_new_kink => T4(new_kink_old_creator, new_kink_new_creator, new_kink_new_annihilator, new_kink_old_annihilator)
            end
        end

        drop_kinks = (old_kink,)

        # MC Step generated by this update
        Δ = Step(Configuration(drop_orbs, drop_kinks...), Configuration(add_orbs, add_kink1, add_kink2))

        @assert(is_type_E(promote(c,Δ).kinks[τ_new_kink], promote(c,Δ).kinks[first(old_kink)]) != false)# TODO: @assert(is_type_E(c.kinks[τ_new_kink], c.kinks[first(old_kink)]))

        #calculate weight differance
        dw_off_diag = get_abs_offdiagonal_element(e,promote(c,Δ),promote(c,Δ).kinks[τ_new_kink]) * get_abs_offdiagonal_element(e,promote(c,Δ),promote(c,Δ).kinks[first(old_kink)]) /
                                                get_abs_offdiagonal_element(e,promote(c,Δ),last(old_kink))
        dw = e.β * dw_off_diag* exp(-(e.β * delta_τ*(get_energy(promote(c,Δ).kinks[τ_new_kink].i) + get_energy(promote(c,Δ).kinks[τ_new_kink].j)-
                                                         get_energy(promote(c,Δ).kinks[τ_new_kink].k) - get_energy(promote(c,Δ).kinks[τ_new_kink].l)) + delta_di))

        inverse_prop_prob = (1.0/length(get_right_type_E_removable_pairs(promote(c,Δ)))) * 0.5 * 0.25

        @assert(inverse_prop_prob != Inf)
    else
        #add kink right
        #now choose orbitals of the old kinks that shell also be part of the new kink
        prop_prob *= 0.5
        if rand() > 0.5
            new_kink_old_creator = last(old_kink).i
            changed_kink_old_creator = last(old_kink).j
        else
            new_kink_old_creator = last(old_kink).j
            changed_kink_old_creator = last(old_kink).i
        end
        prop_prob *= 0.5
        if rand() > 0.5
            new_kink_old_annihilator = last(old_kink).k
            changed_kink_old_annihilator = last(old_kink).l
        else
            new_kink_old_annihilator = last(old_kink).l
            changed_kink_old_annihilator = last(old_kink).k
        end
        #find occupied orb for creation of Type_E
        opportunities_new_kink_new_annihilator = setdiff!(union!(get_sphere_with_same_spin(new_kink_old_creator, dk = ex_radius),
                                                                        get_sphere_with_same_spin(OrbitalHEG(new_kink_old_creator.vec, -new_kink_old_annihilator.spin), dk = ex_radius)), occs)
        delete!(opportunities_new_kink_new_annihilator, last(old_kink).k)
        delete!(opportunities_new_kink_new_annihilator, last(old_kink).l)
        if isempty(opportunities_new_kink_new_annihilator)
            return 1.0, Step()
        end
        new_kink_new_annihilator = rand(opportunities_new_kink_new_annihilator)
        prop_prob *= 1.0/length(opportunities_new_kink_new_annihilator)

        if new_kink_new_annihilator.spin == new_kink_old_annihilator.spin
            new_kink_new_creator = OrbitalHEG(new_kink_old_annihilator.vec + (new_kink_new_annihilator.vec - new_kink_old_creator.vec), new_kink_old_creator.spin)
        else
            new_kink_new_creator = OrbitalHEG(new_kink_old_annihilator.vec + (new_kink_new_annihilator.vec - new_kink_old_creator.vec), -1 * new_kink_old_creator.spin)
        end

        if (!in(new_kink_new_creator, occs) | (new_kink_new_creator == last(old_kink).i) | (new_kink_new_creator == last(old_kink).j))
            return 1.0, Step()
        end

        τ_Intervall = last(get_τ_borders(c, Set([
                        new_kink_old_creator, new_kink_new_creator, new_kink_new_annihilator, new_kink_old_annihilator]),first(old_kink))) -
                        first(old_kink)
        if τ_Intervall < 0
            τ_Intervall +=1
        end
        τ_new_kink = first(old_kink) + ImgTime(rand()*τ_Intervall)
        if τ_new_kink > 1
            τ_new_kink -= 1
            delta_τ = Float64(τ_new_kink - first(old_kink) + 1)
        else
            delta_τ = Float64(τ_new_kink - first(old_kink))
        end

        #no 2 kinks at same τ
        @assert τ_Intervall > 0
        while haskey(c.kinks, τ_new_kink)
            τ_new_kink = first(old_kink) + ImgTime(rand()*τ_Intervall)
            if τ_new_kink > 1
                τ_new_kink -= 1
                delta_τ = Float64(τ_new_kink - first(old_kink) + 1)
            else
                delta_τ = Float64(τ_new_kink - first(old_kink))
            end
        end

        prop_prob *= 1.0/Float64(τ_Intervall)
                                                          #Inverse new kink
        delta_di = get_change_diagonal_interaction(c, e, T4(new_kink_new_annihilator, new_kink_old_annihilator, new_kink_old_creator, new_kink_new_creator), first(old_kink), τ_new_kink)

        #change_Configuration
        #see if c.occupations change
        if τ_new_kink < first(old_kink)  #new kink was added right of old kink
            # change_occupations(c.occupations, T4(new_kink_new_annihilator, new_kink_old_annihilator, new_kink_old_creator, new_kink_new_creator))
            drop_orbs = Set([new_kink_old_creator, new_kink_new_creator])
            add_orbs = Set([new_kink_new_annihilator, new_kink_old_annihilator])
        else
            drop_orbs = Set{basis(c)}()
            add_orbs = Set{basis(c)}()
        end

        # c.kinks[τ_new_kink] = T4(new_kink_old_creator, new_kink_new_creator, new_kink_new_annihilator, new_kink_old_annihilator)
        # c.kinks[first(old_kink)] = T4(changed_kink_old_creator, new_kink_new_annihilator, new_kink_new_creator, changed_kink_old_annihilator)

        # shuffle Indices TODO: is this necessary for ergodicy ?
        # shuffle changed kink
        prop_prob *= 1/16
        if rand() < 0.5
            if rand() < 0.5
                # shuffle both
                # c.kinks[first(old_kink)] = T4(c.kinks[first(old_kink)].j, c.kinks[first(old_kink)].i,c.kinks[first(old_kink)].l, c.kinks[first(old_kink)].k)
                add_kink1 = first(old_kink) => T4(new_kink_new_annihilator, changed_kink_old_creator, changed_kink_old_annihilator, new_kink_new_creator)
            else
                # shuffle annihilators
                # c.kinks[first(old_kink)] = T4(c.kinks[first(old_kink)].i, c.kinks[first(old_kink)].j,c.kinks[first(old_kink)].l, c.kinks[first(old_kink)].k)
                add_kink1 = first(old_kink) => T4(changed_kink_old_creator, new_kink_new_annihilator, changed_kink_old_annihilator, new_kink_new_creator)
            end
        else
            if rand() < 0.5
                # shuffle creators
                # c.kinks[first(old_kink)] = T4(c.kinks[first(old_kink)].j, c.kinks[first(old_kink)].i,c.kinks[first(old_kink)].k, c.kinks[first(old_kink)].l)
                add_kink1 = first(old_kink) => T4(new_kink_new_annihilator, changed_kink_old_creator, new_kink_new_creator, changed_kink_old_annihilator)
            else
                # c.kinks[first(old_kink)] = T4(c.kinks[first(old_kink)].i, c.kinks[first(old_kink)].j,c.kinks[first(old_kink)].k, c.kinks[first(old_kink)].l)
                add_kink1 = first(old_kink) => T4(changed_kink_old_creator, new_kink_new_annihilator, new_kink_new_creator, changed_kink_old_annihilator)
            end
        end
        # shuffle new kink
        if rand() < 0.5
            if rand() < 0.5
                # shuffle both
                # c.kinks[τ_new_kink] = T4(c.kinks[τ_new_kink].j, c.kinks[τ_new_kink].i,c.kinks[τ_new_kink].l, c.kinks[τ_new_kink].k)
                add_kink2 = τ_new_kink => T4(new_kink_new_creator, new_kink_old_creator, new_kink_old_annihilator, new_kink_new_annihilator)
            else
                # shuffle annihilators
                # c.kinks[τ_new_kink] = T4(c.kinks[τ_new_kink].i, c.kinks[τ_new_kink].j,c.kinks[τ_new_kink].l, c.kinks[τ_new_kink].k)
                add_kink2 = τ_new_kink => T4(new_kink_old_creator, new_kink_new_creator, new_kink_old_annihilator, new_kink_new_annihilator)
            end
        else
            if rand() < 0.5
                # shuffle creators
                # c.kinks[τ_new_kink] = T4(c.kinks[τ_new_kink].j, c.kinks[τ_new_kink].i,c.kinks[τ_new_kink].k, c.kinks[τ_new_kink].l)
                add_kink2 = τ_new_kink => T4(new_kink_new_creator, new_kink_old_creator, new_kink_new_annihilator, new_kink_old_annihilator)
            else
                # do not shuffle
                # c.kinks[τ_new_kink] = T4(c.kinks[τ_new_kink].i, c.kinks[τ_new_kink].j,c.kinks[τ_new_kink].k, c.kinks[τ_new_kink].l)
                add_kink2 = τ_new_kink => T4(new_kink_old_creator, new_kink_new_creator, new_kink_new_annihilator, new_kink_old_annihilator)
            end
        end

        drop_kinks = (old_kink,)

        # MC Step generated by this update
        Δ = Step(Configuration(drop_orbs, drop_kinks...), Configuration(add_orbs, add_kink1, add_kink2))

        dw_off_diag = get_abs_offdiagonal_element(e,promote(c,Δ),promote(c,Δ).kinks[τ_new_kink]) * get_abs_offdiagonal_element(e,promote(c,Δ),promote(c,Δ).kinks[first(old_kink)]) /
                                                get_abs_offdiagonal_element(e,promote(c,Δ),last(old_kink))

        dw = e.β * dw_off_diag* exp(-(e.β * delta_τ*(get_energy(promote(c,Δ).kinks[τ_new_kink].k) + get_energy(promote(c,Δ).kinks[τ_new_kink].l) -
                                                         get_energy(promote(c,Δ).kinks[τ_new_kink].i) - get_energy(promote(c,Δ).kinks[τ_new_kink].j)) + delta_di))

        inverse_prop_prob = (1.0/length(get_left_type_E_removable_pairs(promote(c,Δ)))) * 0.5 * 0.25

        @assert(inverse_prop_prob != Inf)
    end

    #check if sign was changend
    signum = 1
    if new_kink_old_creator.spin != new_kink_new_annihilator.spin
        signum*= -1
    elseif new_kink_old_creator.spin != new_kink_old_annihilator.spin
        signum*= 1
    elseif dot((new_kink_old_creator.vec - new_kink_new_annihilator.vec),(new_kink_old_creator.vec - new_kink_new_annihilator.vec)) >
            dot((new_kink_old_creator.vec - new_kink_old_annihilator.vec),(new_kink_old_creator.vec - new_kink_old_annihilator.vec))
        signum*= -1
    end
    if changed_kink_old_creator.spin != new_kink_new_creator.spin
        signum*= -1
    elseif changed_kink_old_creator.spin != changed_kink_old_annihilator.spin
        signum*= 1
    elseif dot((changed_kink_old_creator.vec - new_kink_new_creator.vec),(changed_kink_old_creator.vec - new_kink_new_creator.vec)) >
            dot((changed_kink_old_creator.vec - changed_kink_old_annihilator.vec),(changed_kink_old_creator.vec - changed_kink_old_annihilator.vec))
        signum*= -1
    end
    if new_kink_old_creator.spin != changed_kink_old_annihilator.spin
        signum*= -1
    elseif new_kink_old_creator.spin != new_kink_old_annihilator.spin
        signum*= 1
    elseif dot((new_kink_old_creator.vec - changed_kink_old_annihilator.vec),(new_kink_old_creator.vec - changed_kink_old_annihilator.vec)) >
            dot((new_kink_old_creator.vec - new_kink_old_annihilator.vec),(new_kink_old_creator.vec - new_kink_old_annihilator.vec))
        signum*= -1
    end

    # c.sign *= signum# TODO: this sign-change must be kept in a Step-like object in order to be reversible


    # MOVED THIS TO THE SELECTION OF THE KINKS
    #shuffle Indices
    #shuffle changed kink
    # if rand() < 0.5
    #     if rand() < 0.5
    #         c.kinks[first(old_kink)] = T4(c.kinks[first(old_kink)].j, c.kinks[first(old_kink)].i,
    #                                                     c.kinks[first(old_kink)].l, c.kinks[first(old_kink)].k)
    #     else
    #         c.kinks[first(old_kink)] = T4(c.kinks[first(old_kink)].i, c.kinks[first(old_kink)].j,
    #                                                     c.kinks[first(old_kink)].l, c.kinks[first(old_kink)].k)
    #     end
    # else
    #     if rand() < 0.5
    #         c.kinks[first(old_kink)] = T4(c.kinks[first(old_kink)].j, c.kinks[first(old_kink)].i,
    #                                                     c.kinks[first(old_kink)].k, c.kinks[first(old_kink)].l)
    #     else
    #         c.kinks[first(old_kink)] = T4(c.kinks[first(old_kink)].i, c.kinks[first(old_kink)].j,
    #                                                     c.kinks[first(old_kink)].k, c.kinks[first(old_kink)].l)
    #     end
    # end
    # #shuffle new kink
    # if rand() < 0.5
    #     if rand() < 0.5
    #         c.kinks[τ_new_kink] = T4(c.kinks[τ_new_kink].j, c.kinks[τ_new_kink].i,
    #                                                     c.kinks[τ_new_kink].l, c.kinks[τ_new_kink].k)
    #     else
    #         c.kinks[τ_new_kink] = T4(c.kinks[τ_new_kink].i, c.kinks[τ_new_kink].j,
    #                                                     c.kinks[τ_new_kink].l, c.kinks[τ_new_kink].k)
    #     end
    # else
    #     if rand() < 0.5
    #         c.kinks[τ_new_kink] = T4(c.kinks[τ_new_kink].j, c.kinks[τ_new_kink].i,
    #                                                     c.kinks[τ_new_kink].k, c.kinks[τ_new_kink].l)
    #     else
    #         c.kinks[τ_new_kink] = T4(c.kinks[τ_new_kink].i, c.kinks[τ_new_kink].j,
    #                                                     c.kinks[τ_new_kink].k, c.kinks[τ_new_kink].l)
    #     end
    # end
    # @assert(is_type_E(c.kinks[τ_new_kink], c.kinks[first(old_kink)]) != false)# TODO: @assert(is_type_E(c.kinks[τ_new_kink], c.kinks[first(old_kink)]))
    # prop_prob *= 1/16

    occupations(promote(c,Δ).occupations, promote(c,Δ).kinks)

    @assert(delta_τ > 0 )
    @assert(dw != Inf)
    @assert(prop_prob != 0)
    @assert(inverse_prop_prob != Inf)
    @assert(inverse_prop_prob != 0)
    @assert(!isnan((inverse_prop_prob/prop_prob)*dw))
    return ((inverse_prop_prob/prop_prob)*dw), Δ
end

function remove_type_E(c::Configuration, e::Ensemble) :: Tuple{Float64,Step}
    prop_prob = 0.5
    if rand() > 0.5
        #removed kink left of changed kink
        opportunities = get_right_type_E_removable_pairs(c)
        if isempty(opportunities)
            return 1.0, Step()
        end
        removed_kink_tuple, changed_kink_tuple = rand(opportunities)
        removed_kink_τ =  first(removed_kink_tuple)
        changed_kink_τ =  first(changed_kink_tuple)
        prop_prob *= 1.0/length(opportunities)
        #safe thoose for later
        removed_kink = last(removed_kink_tuple)
        changed_kink_old = last(changed_kink_tuple)
        # if the difference between i and k is larger then ex_radius we can not create the kink and therefore also can't delete it
        if dot(removed_kink.i.vec-removed_kink.k.vec,
                    removed_kink.i.vec-removed_kink.k.vec) > (ex_radius^2)
            @assert false #This should be prevented by using get_right_type_E_removable_pairs TODO: If this really must not happen an ErrorException should be thrown instead of returning something.
            return 1.0, Step()
        end

        #change configuration
        # c.kinks[changed_kink_τ] = T4(removed_kink.i, changed_kink_old.i, removed_kink.l, changed_kink_old.l)
        # add_kinks = (changed_kink_τ => T4(removed_kink.i, changed_kink_old.i, removed_kink.l,changed_kink_old.l),)

        #shuffle Indices TODO: is this necessary for ergodicy ?
        prop_prob *= 0.25
        if rand() < 0.5
            if rand() < 0.5
                # shuffle all
                # c.kinks[changed_kink_τ] = T4(c.kinks[changed_kink_τ].j, c.kinks[changed_kink_τ].i, c.kinks[changed_kink_τ].l, c.kinks[changed_kink_τ].k)
                add_kinks = (changed_kink_τ => T4(changed_kink_old.i, removed_kink.i, changed_kink_old.l, removed_kink.l),)
            else
                # shuffle annihilators
                # c.kinks[changed_kink_τ] = T4(c.kinks[changed_kink_τ].i, c.kinks[changed_kink_τ].j,c.kinks[changed_kink_τ].l, c.kinks[changed_kink_τ].k)
                add_kinks = (changed_kink_τ => T4(removed_kink.i, changed_kink_old.i, changed_kink_old.l, removed_kink.l),)
            end
        else
            if rand() < 0.5
                # shuffle creators
                # c.kinks[changed_kink_τ] = T4(c.kinks[changed_kink_τ].j, c.kinks[changed_kink_τ].i,c.kinks[changed_kink_τ].k, c.kinks[changed_kink_τ].l)
                add_kinks = (changed_kink_τ => T4(changed_kink_old.i, removed_kink.i, removed_kink.l, changed_kink_old.l),)
            else
                # do note shuffle
                # c.kinks[changed_kink_τ] = T4(c.kinks[changed_kink_τ].i, c.kinks[changed_kink_τ].j,c.kinks[changed_kink_τ].k, c.kinks[changed_kink_τ].l)
                add_kinks = (changed_kink_τ => T4(removed_kink.i, changed_kink_old.i, removed_kink.l, changed_kink_old.l),)
            end
        end

        # see if c.occupations change
        if removed_kink_τ > changed_kink_τ
            # change_occupations(c.occupations, T4(removed_kink.k,removed_kink.l, removed_kink.i,removed_kink.j))
            drop_orbs = Set([removed_kink.i,removed_kink.j])
            add_orbs = Set([removed_kink.k,removed_kink.l])
        else
            drop_orbs = Set{basis(c)}()
            add_orbs = Set{basis(c)}()
        end

        # delete!(c.kinks, removed_kink_τ)
        drop_kinks = (changed_kink_τ => c.kinks[changed_kink_τ], removed_kink_τ => c.kinks[removed_kink_τ])

        # MC Step generated by this update
        Δ = Step(Configuration(drop_orbs, drop_kinks...), Configuration(add_orbs, add_kinks...))

        #calculate reverse_prop_prob
        occs = occupations(promote(c,Δ), changed_kink_τ)
        opportunities_occ_orb_E = intersect!(union!(get_sphere_with_same_spin(OrbitalHEG(removed_kink.i.vec, 1), dk = ex_radius), get_sphere_with_same_spin(OrbitalHEG(removed_kink.i.vec, -1), dk = ex_radius)), occs)
        delete!(opportunities_occ_orb_E, promote(c,Δ).kinks[changed_kink_τ].i)
        delete!(opportunities_occ_orb_E, promote(c,Δ).kinks[changed_kink_τ].j)
        @assert(in(removed_kink.k,opportunities_occ_orb_E))
        τ_Intervall = changed_kink_τ - first(get_τ_borders(promote(c,Δ), Set([removed_kink.k, removed_kink.l,removed_kink.i, removed_kink.j]),changed_kink_τ))


        if τ_Intervall < 0
            τ_Intervall +=1
        end

        inverse_prop_prob = (0.5/length(promote(c,Δ).kinks)) * (1.0/length(opportunities_occ_orb_E)) *
                                 (1.0/Float64(τ_Intervall)) * (1/4) * (1/16)

        #calculate weight change
        delta_di = get_change_diagonal_interaction(promote(c,Δ), e, removed_kink, removed_kink_τ, changed_kink_τ)

        dw_off_diag = get_abs_offdiagonal_element(e,promote(c,Δ),removed_kink) *
                        get_abs_offdiagonal_element(e,promote(c,Δ),changed_kink_old) /
                            get_abs_offdiagonal_element(e,promote(c,Δ),promote(c,Δ).kinks[changed_kink_τ])

        delta_τ = Float64(changed_kink_τ - removed_kink_τ)
        if delta_τ < 0
            delta_τ +=1
        end
        dw = (1.0/e.β)* (1.0/dw_off_diag) * exp(e.β * delta_τ * (get_energy(removed_kink.i) + get_energy(removed_kink.j) -
                                                                    get_energy(removed_kink.k) - get_energy(removed_kink.l)) + delta_di)

    else
        #removed kink right of changed kink
        opportunities = get_left_type_E_removable_pairs(c)
        if isempty(opportunities)
            return 1.0, Step()
        end
        removed_kink_tuple, changed_kink_tuple = rand(opportunities)
        removed_kink_τ = first(removed_kink_tuple)
        changed_kink_τ = first(changed_kink_tuple)
        prop_prob *= 1.0/length(opportunities)
        removed_kink = last(removed_kink_tuple)
        changed_kink_old = last(changed_kink_tuple)
        if removed_kink.i.spin != removed_kink.k.spin
            return 1.0, Step()
        end
        # if the difference between i and k is larger then ex_radius we can not create the kink and therefore also can't delete it
        if dot(removed_kink.i.vec-removed_kink.k.vec,
                    removed_kink.i.vec-removed_kink.k.vec) > (ex_radius^2)
            @assert false #This should not happen when using get_left_type_E_removable_pairs(c)TODO: If this really must not happen an ErrorException should be thrown instead of returning something.
            return 1.0, Step()
        end


        #change configuration
        # c.kinks[changed_kink_τ] = T4(removed_kink.i, changed_kink_old.i, removed_kink.l, changed_kink_old.l)
        # add_kinks = (changed_kink_τ => T4(removed_kink.i, changed_kink_old.i, removed_kink.l, changed_kink_old.l),)

        #shuffle Indices TODO: is this necessary for ergodicy ?
        prop_prob *= 0.25
        if rand() < 0.5
            if rand() < 0.5
                # shuffle all
                # c.kinks[changed_kink_τ] = T4(c.kinks[changed_kink_τ].j, c.kinks[changed_kink_τ].i,c.kinks[changed_kink_τ].l, c.kinks[changed_kink_τ].k)
                add_kinks = (changed_kink_τ => T4(changed_kink_old.i, removed_kink.i, changed_kink_old.l, removed_kink.l),)
            else
                # shuffle annihilators
                # c.kinks[changed_kink_τ] = T4(c.kinks[changed_kink_τ].i, c.kinks[changed_kink_τ].j,c.kinks[changed_kink_τ].l, c.kinks[changed_kink_τ].k)
                add_kinks = (changed_kink_τ => T4(removed_kink.i, changed_kink_old.i, changed_kink_old.l, removed_kink.l),)
            end
        else
            if rand() < 0.5
                # shuffle creators
                # c.kinks[changed_kink_τ] = T4(c.kinks[changed_kink_τ].j, c.kinks[changed_kink_τ].i,c.kinks[changed_kink_τ].k, c.kinks[changed_kink_τ].l)
                add_kinks = (changed_kink_τ => T4(changed_kink_old.i, removed_kink.i, removed_kink.l, changed_kink_old.l),)
            else
                # do note shuffle
                # c.kinks[changed_kink_τ] = T4(c.kinks[changed_kink_τ].i, c.kinks[changed_kink_τ].j,c.kinks[changed_kink_τ].k, c.kinks[changed_kink_τ].l)
                add_kinks = (changed_kink_τ => T4(removed_kink.i, changed_kink_old.i, removed_kink.l, changed_kink_old.l),)
            end
        end

        #see if c.occupations change
        if removed_kink_τ < changed_kink_τ  #new kink was added right of old kink
            # change_occupations(c.occupations, T4(removed_kink.i, removed_kink.j, removed_kink.k,removed_kink.l))
            drop_orbs = Set([removed_kink.k,removed_kink.l])
            add_orbs = Set([removed_kink.i, removed_kink.j])
        else
            drop_orbs = Set{basis(c)}()
            add_orbs = Set{basis(c)}()
        end

        # delete!(c.kinks, removed_kink_τ)
        drop_kinks = (changed_kink_τ => c.kinks[changed_kink_τ], removed_kink_τ => c.kinks[removed_kink_τ])

        # MC Step generated by this update
        Δ = Step(Configuration(drop_orbs, drop_kinks...), Configuration(add_orbs, add_kinks...))

        #calculate reverse_prop_prob
        occs = occupations(promote(c,Δ), changed_kink_τ)
        opportunities_unocc_orb_E = setdiff!(union!(get_sphere_with_same_spin(OrbitalHEG(removed_kink.i.vec, 1), dk = ex_radius), get_sphere_with_same_spin(OrbitalHEG(removed_kink.i.vec, -1), dk = ex_radius)), occs)
        delete!(opportunities_unocc_orb_E, promote(c,Δ).kinks[changed_kink_τ].k)
        delete!(opportunities_unocc_orb_E, promote(c,Δ).kinks[changed_kink_τ].l)
        @assert(in(removed_kink.k,opportunities_unocc_orb_E))
        τ_Intervall =  last(get_τ_borders(promote(c,Δ), Set([removed_kink.i, removed_kink.j,removed_kink.k, removed_kink.l]),changed_kink_τ)) - changed_kink_τ

        if τ_Intervall < 0
            τ_Intervall +=1
        end
        inverse_prop_prob = (0.5/length(promote(c,Δ).kinks)) * (1/length(opportunities_unocc_orb_E)) *
                                 (1.0/Float64(τ_Intervall)) * (1/4) * (1/16)

        #calculate weight change
        delta_di = get_change_diagonal_interaction(promote(c,Δ), e, T4(removed_kink.k,removed_kink.l, removed_kink.i,removed_kink.j), changed_kink_τ, removed_kink_τ)

        dw_off_diag = get_abs_offdiagonal_element(e,promote(c,Δ),removed_kink) *
                        get_abs_offdiagonal_element(e,promote(c,Δ),changed_kink_old) /
                            get_abs_offdiagonal_element(e,promote(c,Δ),promote(c,Δ).kinks[changed_kink_τ])

        delta_τ = Float64(removed_kink_τ - changed_kink_τ)
        if delta_τ < 0
            delta_τ +=1
        end
        dw = (1.0/e.β)*(1.0/dw_off_diag) * exp(e.β * delta_τ*(get_energy(removed_kink.k) + get_energy(removed_kink.l) -
                                                            get_energy(removed_kink.i) - get_energy(removed_kink.j)) + delta_di)

    end

    #check if sign was changend
    signum = 1
    if changed_kink_old.i.spin != changed_kink_old.k.spin
        signum*= -1
    elseif changed_kink_old.i.spin != changed_kink_old.l.spin
        signum*= 1
    elseif dot((changed_kink_old.i.vec - changed_kink_old.k.vec),(changed_kink_old.i.vec - changed_kink_old.k.vec)) >
            dot((changed_kink_old.i.vec - changed_kink_old.l.vec),(changed_kink_old.i.vec - changed_kink_old.l.vec))
        signum*= -1
    end
    if removed_kink.i.spin != removed_kink.k.spin
        signum*= -1
    elseif removed_kink.i.spin != removed_kink.l.spin
        signum*= 1
    elseif dot((removed_kink.i.vec - removed_kink.k.vec),(removed_kink.i.vec - removed_kink.k.vec)) >
            dot((removed_kink.i.vec - removed_kink.l.vec),(removed_kink.i.vec - removed_kink.l.vec))
        signum*= -1
    end
    if changed_kink_old.i.spin != removed_kink.l.spin
        signum*= -1
    elseif changed_kink_old.i.spin != changed_kink_old.l.spin
        signum*= 1
    elseif dot((changed_kink_old.i.vec - removed_kink.l.vec),(changed_kink_old.i.vec - removed_kink.l.vec)) >
            dot((changed_kink_old.i.vec - changed_kink_old.l.vec),(changed_kink_old.i.vec - changed_kink_old.l.vec))
        signum*= -1
    end

    """if dot((changed_kink_old.i.vec - changed_kink_old.k.vec),(changed_kink_old.i.vec - changed_kink_old.k.vec)) >
            dot((changed_kink_old.i.vec - changed_kink_old.l.vec),(changed_kink_old.i.vec - changed_kink_old.l.vec))
        signum*= -1
    end
    if dot((removed_kink.i.vec - removed_kink.k.vec),(removed_kink.i.vec - removed_kink.k.vec)) >
            dot((removed_kink.i.vec - removed_kink.l.vec),(removed_kink.i.vec - removed_kink.l.vec))
        signum*= -1
    end
    if dot((changed_kink_old.i.vec - removed_kink.l.vec),(changed_kink_old.i.vec - removed_kink.l.vec)) >
            dot((changed_kink_old.i.vec - changed_kink_old.l.vec),(changed_kink_old.i.vec - changed_kink_old.l.vec))
        signum*= -1
    end"""
    # c.sign *= signum# TODO: this sign-change must be kept in a Step-like object in order to be reversible

    # MOVED THIS TO THE SELECTION OF THE KINKS
    #shuffle Indices
    # if rand() < 0.5
    #     if rand() < 0.5
    #         c.kinks[changed_kink_τ] = T4(c.kinks[changed_kink_τ].j, c.kinks[changed_kink_τ].i,
    #                                                     c.kinks[changed_kink_τ].l, c.kinks[changed_kink_τ].k)
    #     else
    #         c.kinks[changed_kink_τ] = T4(c.kinks[changed_kink_τ].i, c.kinks[changed_kink_τ].j,
    #                                                     c.kinks[changed_kink_τ].l, c.kinks[changed_kink_τ].k)
    #     end
    # else
    #     if rand() < 0.5
    #         c.kinks[changed_kink_τ] = T4(c.kinks[changed_kink_τ].j, c.kinks[changed_kink_τ].i,
    #                                                     c.kinks[changed_kink_τ].k, c.kinks[changed_kink_τ].l)
    #     else
    #         c.kinks[changed_kink_τ] = T4(c.kinks[changed_kink_τ].i, c.kinks[changed_kink_τ].j,
    #                                                     c.kinks[changed_kink_τ].k, c.kinks[changed_kink_τ].l)
    #     end
    # end
    # prop_prob *= 0.25

    occupations(promote(c,Δ).occupations, promote(c,Δ).kinks)


    @assert(dw != Inf)
    @assert(delta_τ > 0 )
    @assert(!isnan((inverse_prop_prob/prop_prob) * dw))

    return ((inverse_prop_prob/prop_prob) * dw), Δ
end



# TODO use Step()
function shuffle_indices(c::Configuration, e::Ensemble)
    if isempty(c.kinks)
        return 1.0, Step()
    end
    kink = rand(c.kinks)
    if rand() > 0.5
        # shuffle creators
        # c.kinks[first(kink)] = T4(last(kink).j,last(kink).i,last(kink).k,last(kink).l)
        Δ = Step(Configuration(kink), Configuration(first(kink) => T4(last(kink).j,last(kink).i,last(kink).k,last(kink).l)))
    else
        # shuffle annihilators
        c.kinks[first(kink)] = T4(last(kink).i,last(kink).j,last(kink).l,last(kink).k)
        Δ = Step(Configuration(kink), Configuration(first(kink) => T4(last(kink).i,last(kink).j,last(kink).l,last(kink).k)))
    end
    return 1.0, Step()
end

""" perform a number of subsequent updates
    first perform a number of updates which add kinks
    second perform the same number of updates which remove kinks """
function add_remove_kink_chain(c::Configuration,e::Ensemble)
    if isempty(c.kinks)
        return 1.0, Step()
    end
    add_single_kinks = [add_type_C, add_type_D, add_type_E]
    remove_single_kinks = [remove_type_C, remove_type_D, remove_type_E]
    chain_length = rand(1:9)
    acc_prob = 1.0
    step_list = Array{Step,1}()
    for i in  1:chain_length
        dv, Δ = rand(add_single_kinks)(promote(c,step_list),e)
        acc_prob *= dv
        if iszero(acc_prob)
            return 0.0, Step()
        end
        push!(step_list, Δ)
    end
    for i in  1:chain_length
        dv, Δ = rand(remove_single_kinks)(promote(c,step_list),e)
        acc_prob *= dv
        if iszero(acc_prob)
            return 0.0, Step()
        end
        push!(step_list, Δ)
    end
    return acc_prob, step_list
end

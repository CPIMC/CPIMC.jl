var documenterSearchIndex = {"docs":
[{"location":"planewaves/#PlaneWaves","page":"PlaneWaves","title":"PlaneWaves","text":"","category":"section"},{"location":"planewaves/","page":"PlaneWaves","title":"PlaneWaves","text":"CurrentModule = CPIMC.PlaneWaves","category":"page"},{"location":"planewaves/","page":"PlaneWaves","title":"PlaneWaves","text":"PlaneWaves","category":"page"},{"location":"planewaves/#CPIMC.PlaneWaves","page":"PlaneWaves","title":"CPIMC.PlaneWaves","text":"Plane wave single-particle basis states.\n\n\n\n\n\n","category":"module"},{"location":"planewaves/","page":"PlaneWaves","title":"PlaneWaves","text":"PlaneWave\ndimension","category":"page"},{"location":"planewaves/#CPIMC.PlaneWaves.PlaneWave","page":"PlaneWaves","title":"CPIMC.PlaneWaves.PlaneWave","text":"struct PlaneWave{D} <: Orbital\n\nRepresentation of plane wave single-particle states with dimensionality D.\n\nFields\n\nvec  :: StaticVector{D,Int} – momentum vector\nspin :: Spin                – spin\n\n\n\n\n\n","category":"type"},{"location":"planewaves/#CPIMC.PlaneWaves.dimension","page":"PlaneWaves","title":"CPIMC.PlaneWaves.dimension","text":"dimension(o::PlaneWave{D}) where {D}\n\nreturn the dimension of the momentum vector of an Orbital\n\n\n\n\n\ndimension(os::Set{<:PlaneWave{D}}) where {D}\n\nreturn the dimension of the momentum vectors of a Set{<:Orbital{D}}\n\n\n\n\n\n","category":"function"},{"location":"planewaves/","page":"PlaneWaves","title":"PlaneWaves","text":"Spin\nflip\nfractional_spin_polarization\nξ","category":"page"},{"location":"planewaves/#CPIMC.PlaneWaves.Spin","page":"PlaneWaves","title":"CPIMC.PlaneWaves.Spin","text":"Type for storing spin projection of particles with spin 1/2.\n\n\n\n\n\n","category":"type"},{"location":"planewaves/#CPIMC.PlaneWaves.flip","page":"PlaneWaves","title":"CPIMC.PlaneWaves.flip","text":"flip(s::Spin)\n\nreturn opposite spin projection\n\n\n\n\n\nflip(o::PlaneWave)\n\nreturn an PlaneWave with the same momentum vector but opposite spin projection as the given o::PlaneWave \n\n\n\n\n\n","category":"function"},{"location":"planewaves/#CPIMC.PlaneWaves.fractional_spin_polarization","page":"PlaneWaves","title":"CPIMC.PlaneWaves.fractional_spin_polarization","text":"fractional_spin_polarization(occ::Set{PlaneWave)\n\ncalculate the fractional spin polarization from a set of Orbitals which each must have a field spin of type @enum Spin Down Up, the fractional spin polarization is defined as the ratio of the absolute difference of the number of particles which Spin Down and Spin Up and the particle number, thus here no convention is made as to which spin component should be occupied more often, as opposed to some literature where N↑ > N↓ is used\n\n\n\n\n\nfractional_spin_polarization(c::Configuration{<:PlaneWave})\n\ncalculate the fractional spin polarization from a set of Orbitals which each must have a field spin of type @enum Spin Down Up, the fractional spin polarization is defined as the ratio of the absolute difference of the number of particles which Spin Down and Spin Up and the particle number, thus here no convention is made as to which spin component should be occupied more often, as opposed to some literature where N↑ > N↓ is used\n\n\n\n\n\n","category":"function"},{"location":"planewaves/#CPIMC.PlaneWaves.ξ","page":"PlaneWaves","title":"CPIMC.PlaneWaves.ξ","text":"ξ(occ::Set{PlaneWave})\n\ncalculate the fractional spin polarization from a set of Orbitals which each must have a field spin of type @enum Spin Down Up, the fractional spin polarization is defined as the ratio of the absolute difference of the number of particles which Spin Down and Spin Up and the particle number, thus here no convention is made as to which spin component should be occupied more often, as opposed to some literature where N↑ > N↓ is used\n\n\n\n\n\nξ(c::Configuration{<:PlaneWave})\n\ncalculate the fractional spin polarization from a set of Orbitals which each must have a field spin of type @enum Spin Down Up, the fractional spin polarization is defined as the ratio of the absolute difference of the number of particles which Spin Down and Spin Up and the particle number, thus here no convention is made as to which spin component should be occupied more often, as opposed to some literature where N↑ > N↓ is used\n\n\n\n\n\n","category":"function"},{"location":"planewaves/","page":"PlaneWaves","title":"PlaneWaves","text":"shell\nsphere\nsphere_with_same_spin","category":"page"},{"location":"planewaves/#CPIMC.PlaneWaves.shell","page":"PlaneWaves","title":"CPIMC.PlaneWaves.shell","text":"shell(o::PlaneWave{1};dw::Int=2)\nshell(o::PlaneWave{2};dw::Int=2)\nshell(o::PlaneWave{3};dw::Int=2)\n\nReturns a set of all PlaneWave orbitals lying in the dwth shell.\n\n\n\n\n\n","category":"function"},{"location":"planewaves/#CPIMC.PlaneWaves.sphere","page":"PlaneWaves","title":"CPIMC.PlaneWaves.sphere","text":"return two spheres of each spin with radius dk around the wavevector of the argument orbital o\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.jl","page":"CPIMC.jl","title":"CPIMC.jl","text":"","category":"section"},{"location":"cpimc/","page":"CPIMC.jl","title":"CPIMC.jl","text":"CurrentModule = CPIMC","category":"page"},{"location":"cpimc/","page":"CPIMC.jl","title":"CPIMC.jl","text":"CPIMC","category":"page"},{"location":"cpimc/#CPIMC.CPIMC","page":"CPIMC.jl","title":"CPIMC.CPIMC","text":"Common functionality to simulate any physical model.\n\n\n\n\n\n","category":"module"},{"location":"cpimc/#sweep!,-measure!,-update!","page":"CPIMC.jl","title":"sweep!, measure!, update!","text":"","category":"section"},{"location":"cpimc/","page":"CPIMC.jl","title":"CPIMC.jl","text":"sweep!\nmeasure!\nupdate!\nprint_results","category":"page"},{"location":"cpimc/#CPIMC.sweep!","page":"CPIMC.jl","title":"CPIMC.sweep!","text":"sweep!(m::Model, e::Ensemble, c::Configuration, updates, estimators, steps::Int, sampleEvery::Int, throwAway::Int)\n\nGenerate a markov chain of length steps using the Metropolis-Hastings algorithm with the updates given in updates. After throwAway steps have been performed, the observables given in estimators are calculated every sampleEvery steps.\n\nReturns a dictionary containing an UpdateCounter for every function given in updates.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.measure!","page":"CPIMC.jl","title":"CPIMC.measure!","text":"measure!(m::Model, e::Ensemble, c::Configuration, estimators)\n\nPerform measurements on a Configuration. estimators needs to be a dictionary that contains tuples (::OnlineStat, ::Function).\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.update!","page":"CPIMC.jl","title":"CPIMC.update!","text":"update!(m::Model, e::Ensemble, c::Configuration, updates)\n\nObtain the next state of the Markov chain by randomly selecting an element of updates and applying the proposed changes to c with the calculated probability. Returns a tuple containing the index of the chosen function and :accept, :reject or :trivial if the function yielded an empty Step.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.print_results","page":"CPIMC.jl","title":"CPIMC.print_results","text":"print_results(measurements, e::Ensemble)\n\nPrint all measured observables, potentially taking the sign into account.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#Model","page":"CPIMC.jl","title":"Model","text":"","category":"section"},{"location":"cpimc/","page":"CPIMC.jl","title":"CPIMC.jl","text":"Model\nOrbital","category":"page"},{"location":"cpimc/#CPIMC.Model","page":"CPIMC.jl","title":"CPIMC.Model","text":"abstract type Model end\n\nAbstract type for the representation of a physical model for which calculations can be performed. Needs to be implemented system-specifically, in particular the following functions need to be defined: (for now)\n\nthe one-particle matrix element, energy(::Model, ::Orbital)\nthe two-particle matrix element, w(::Model, ::Orbital, ::Orbital, ::Orbital, ::Orbital)\n\n\n\n\n\n","category":"type"},{"location":"cpimc/#CPIMC.Orbital","page":"CPIMC.jl","title":"CPIMC.Orbital","text":"Abstract type for single-particle basis states, implementation is required for each model.\n\n\n\n\n\n","category":"type"},{"location":"cpimc/#Configuration","page":"CPIMC.jl","title":"Configuration","text":"","category":"section"},{"location":"cpimc/","page":"CPIMC.jl","title":"CPIMC.jl","text":"Configuration\nImgTime\nΔ\nKink\nKinks\nT2\nT4\nbasis\norbs\ncreators\nannihilators\nexcite\nexcite!\noccupations_at\nnext\nprev","category":"page"},{"location":"cpimc/#CPIMC.Configuration","page":"CPIMC.jl","title":"CPIMC.Configuration","text":"Multi-particle trajectory in imaginary time.\n\nConfiguration{T} is a parametric type depending on the single-particle basis T <: Orbital.\n\nFields\n\noccupations :: Set{T}  – orbitals which are occupied initially (τ=0)\nkinks :: Kinks{T}      – collection of excitations and their imaginary times (kinks)\n\n\n\n\n\n","category":"type"},{"location":"cpimc/#CPIMC.ImgTime","page":"CPIMC.jl","title":"CPIMC.ImgTime","text":"Type alias for imaginary time. FixedPointNumbers are used since these are stable for == and are thus stable as times in Dict.\n\n\n\n\n\n","category":"type"},{"location":"cpimc/#CPIMC.Δ","page":"CPIMC.jl","title":"CPIMC.Δ","text":"Δ(::ImgTime,::ImgTime)\n\nreturn the length of the periodic interval between the two ::ImgTimes\n\nthe periodic distance of two imaginary times:\n\n`Δ(τ1,τ2) = τ2 - τ1` if `τ2 >= τ1` and\n`Δ(τ1,τ2) = 1 - (τ1 - τ2) = 1 + τ2 - τ1` else\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.Kink","page":"CPIMC.jl","title":"CPIMC.Kink","text":"const Kink{T} = Union{T2{T}, T4{T}}\n\nParametric type representing either a one- or a two-particle scattering event given by types 'T2{T}' and 'T4{T}', respectively. This term is motivated by the geometrical interpretation of a path in Configuration Path Integral Monte Carlo formulation of the partition function in occupation number representation. Discrete occupations are given by horizontal lines of (quasi-)particles occupying the corresponding single-particle states and where transitions between these states are thus indicated by vertical 'kinks' connecting the orbital lines that are part of the transition.\n\n\n\n\n\n","category":"type"},{"location":"cpimc/#CPIMC.Kinks","page":"CPIMC.jl","title":"CPIMC.Kinks","text":"const Kinks{T} = Vector{Pair{ImgTime, Kink{T}}}\n\nStructure for storing excitations and their imaginary times (kinks).\n\nCan also be constructed by passing such pairs directly.\n\nKinks(pairs::Pair{ImgTime,<:Kink{T}}...)\n\n\n\n\n\n","category":"type"},{"location":"cpimc/#CPIMC.T2","page":"CPIMC.jl","title":"CPIMC.T2","text":"T2{T}\n\nParametric type representing a 1-particle excitation by specifying a transition from one state (annihilator) to another (creator). In the occupation number representation, this reads\n\na^dagger_i a_j\n\nwith a creator orbital i and an annihilator orbital j. The single-particle basis is represented by the type parameter T.\n\n\n\n\n\n","category":"type"},{"location":"cpimc/#CPIMC.T4","page":"CPIMC.jl","title":"CPIMC.T4","text":"T4{T}\n\nParametric type representing a 2-particle excitation by specifying a transition from two state (annihilators) to two other (creator) states. In the occupation number representation, this reads\n\na^dagger_i a^dagger_j a_k a_l\n\nwith creator orbitals i, j and an annihilator orbitals k, l. The single-particle basis is represented by the type parameter T.\n\n\n\n\n\n","category":"type"},{"location":"cpimc/#CPIMC.basis","page":"CPIMC.jl","title":"CPIMC.basis","text":"basis(c::Configuration{T})\n\nReturn type parameter T of the configuration.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.orbs","page":"CPIMC.jl","title":"CPIMC.orbs","text":"orbs(::T2)\n\nReturn a Tuple of all orbitals that are affected by a T2-kink in the conventional ordering i, j.\n\n\n\n\n\norbs(::T4)\n\nReturn a Tuple of all orbitals that are affected by a T4-kink in the conventional ordering i, j, k, l. This corresponds to the matrix element w_ijkl in the same order.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.creators","page":"CPIMC.jl","title":"CPIMC.creators","text":"creators(::T4)\n\nreturn a set of the two creators which are affected by a T4 kink\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.annihilators","page":"CPIMC.jl","title":"CPIMC.annihilators","text":"annihilators(x::T4)\n\nreturn a set of the two annihilators which are affected by a T4 kink\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.excite","page":"CPIMC.jl","title":"CPIMC.excite","text":"excite(::Set{T}, ::T4{T})\n\nApply a kink to a set of basis states, i.e. return a set of basis states where the states specified by the creators of the kink are added and the states specified by the annihilators of the kink are dropped from the given set of basis states. This has the physical meaning of a two-particle scattering event where two (quasi-)particles in a many-body state change the single-particle states they occupy. In occupation number representation this reads\n\na^dagger_i a^dagger_j a_k a_l nrangle\n\nfor creator orbitals i and j and annihilator orbitals k and l. This function assumes fermionic particle statistics (Pauli principle),\n\na^dagger_i a^dagger_i = a_i a_i = 0\n\ni.e. the target (creator) states must not be occupied and the initial (annihilator) states must be occupied in the given set of states.\n\n\n\n\n\nexcite(o::Set{T}, κ::Pair{ImgTime,T4{T}})\n\nApply a T4-kink to a set of basis states for a pair of a time and a T4-kink. This is useful for iterating over a Kinks-object when calculating the occupations at a specific time.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.excite!","page":"CPIMC.jl","title":"CPIMC.excite!","text":"excite!(::Set{T}, i::T, j::T, k::T, l::T) where {T}\nexcite!(o::Set{T}, κ::T4{T})\n\nApply an excitation in-place to a set of basis states that is given by creating orbitals i, j and annihilating the orbitals k, l.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.occupations_at","page":"CPIMC.jl","title":"CPIMC.occupations_at","text":"occupations_at(o::Set{T}, kinks::Kinks{T})\n\nReturn the occupied orbitals after applying all kinks to initial occupation.\n\n\n\n\n\noccupations_at(c::Configuration, τ::ImgTime)\n\nReturn the occupied orbitals to the right of τ.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.next","page":"CPIMC.jl","title":"CPIMC.next","text":"next(a, τ)\n\nReturn index of the first kink after to the given τ. If there is no kink with ::ImgTime larger than τ, return index of first kink. Throw a DomainError if an empty list is passed as first argument.\n\nThis function assumes that the kinks in a are ordered with respect to their imaginary time!\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.prev","page":"CPIMC.jl","title":"CPIMC.prev","text":"prev(a, τ)\n\nReturn the index of the first kink earlier than τ::ImgTime. If there is no such kink the last kink is returned. Throw a DomainError if an empty list is passed as first argument.\n\nThis function assumes that the kinks in x are ordered with respect to their imaginary time!\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#weight-calculation","page":"CPIMC.jl","title":"weight calculation","text":"","category":"section"},{"location":"cpimc/","page":"CPIMC.jl","title":"CPIMC.jl","text":"ΔWdiag_element\nΔW_diag\nΔWoffdiag_element\nΔT_element\nWoffdiag_element\nsign_offdiagonal_product\nladder_operator_order_factor\nwminus","category":"page"},{"location":"cpimc/#CPIMC.ΔWdiag_element","page":"CPIMC.jl","title":"CPIMC.ΔWdiag_element","text":"ΔWdiag_element(::Model, ::Ensemble, ::Configuration, i, j, k, l, τ1, τ2)\n\nCalculate the change in the diagonal interaction many-body matrix element due to a change in the occupations given by creating two orbitals i and j and annihilating two orbitals k, l in the interval (τ1, τ2). This interval may be periodically extended over the bounds (0,1) if τ1 > τ2, i.e. the change in the occupation is considered for (τ1,1] ∪ [0,τ2) in that case. We do not need to evaluate the diagonal interaction between all orbitals in all time-intervalls, but it is sufficient to evaluate the full diagonal interaction with the occupations at the start of the intervall and then consider only contributions of orbitals that are changed by kinks in the intervall.\n\n\n\n\n\nΔWdiag_element(::Model, ::Ensemble, ::Configuration, i, j, τ1, τ2)\n\nCalculate the change in the diagonal interaction many-body matrix element due to a change in the occupations given by creating an orbital i and annihilating an orbital j in the interval (τ1, τ2). This interval may be periodically extended over the bounds (0,1) if τ1 > τ2, i.e. the change in the occupation is considered for (τ1,1] ∪ [0,τ2) in that case. We do not need to evaluate the diagonal interaction between all orbitals in all time-intervalls, but it is sufficient to evaluate the full diagonal interaction with the occupations at the start of the intervall and then consider only contributions of orbitals that are changed by kinks in the intervall.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.ΔW_diag","page":"CPIMC.jl","title":"CPIMC.ΔW_diag","text":"ΔW_diag(m::Model, i, j, k, l, occ)\n\nchange in the diagonal interaction matrix element due to a change in the occupation occ in a periodic interval (τ1,τ2) where no kinks occur the change in the occupation is assumed to consist in a creation of two orbitals i, j and in the annihlation of two orbitals k, l\n\n\n\n\n\nΔW_diag(m::Model, i, j, occ)\n\nchange in the diagonal interaction matrix element due to a change in the occupation occ in a periodic interval (τ1,τ2) where no kinks occur the change in the occupation is assumed to consist in a creation of one orbitals i and in the annihlation of one orbitals j\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.ΔWoffdiag_element","page":"CPIMC.jl","title":"CPIMC.ΔWoffdiag_element","text":"ΔWoffdiag_element(::Model, e::Ensemble, itr, itr)\n\nreturn the change in the offdiagonal many body matrix element of the interaction operator given by adding the kinks in the first iterable and removing the kinks in the second iterable\n\nboth arguments itr are required to be iterables containing kinks\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.ΔT_element","page":"CPIMC.jl","title":"CPIMC.ΔT_element","text":"ΔT_element(::Model, i,j,k,l)\n\nreturn the change in the kinetic many body matrix element due to creating orbitals i, j and annihilating orbitals k, l\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.Woffdiag_element","page":"CPIMC.jl","title":"CPIMC.Woffdiag_element","text":"Woffdiag_element(::Model, ::Ensemble, ::Orbital, ::Orbital, ::Orbital, ::Orbital)\n\nReturn the offdiagonal many body matrix element of the interaction operator\n\nfrac14 ( w_ijkl - w_ijlk ) (pm langletildenn^ij_klrangle)\n\nfor an excitation given by creating orbitals i,j and annihilating orbitals k, l as given by the Slater-Condon rules.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.sign_offdiagonal_product","page":"CPIMC.jl","title":"CPIMC.sign_offdiagonal_product","text":"sign_offdiagonal_product(::Model, ::Configuration)\n\nReturn the sign of the product of two-particle terms in the offdiagonal many-body matrix elements. These are given by function wminus, i.e.\n\nlangle tilden  a^dagger_i a^dagger_j a_k a_l  n rangle\n    = pm ( w_ijkl - w_ijlk ) text for  tilden = n_kl^ij\n\nthe term in the braces may be negative and this function returns the product of the sign of all these contributions w_ijkl - w_ijlk from all kinks. The sign pm is determined from the permutation factor of the orbitals i,j,k,l and is not calculated here.\n\nused for the calculation the sign of the weight function\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.ladder_operator_order_factor","page":"CPIMC.jl","title":"CPIMC.ladder_operator_order_factor","text":"ladder_operator_order_factor(sortedlist::Array{<:Orbital,1})\n\nReturns 1 or -1 depending on the order of all ladder operators as given by a list of orbitals.\n\n\n\n\n\nladder_operator_order_factor(ck::Kinks)\n\nReturns 1 or -1 depending on the order of all ladder operators as given by the orbitals that affect each kink in the time-ordering of the kinks and in the conventional ordering i, j, k, l, used in the sign estimator.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.wminus","page":"CPIMC.jl","title":"CPIMC.wminus","text":"wminus(::Model, i,j,k,l)\n\nreturn the difference of the two-particle matrix element with the same but the last two indices transposed antisymmetric difference of the two-particle matrix elements:\n\nw^-_ijkl = w_ijkl - w_ijlk\n\nThis is called the antisymmetrized two-particle matrix element. This is an abbreviation for these terms arising in the Slater-Condon rules for the calculation of the many-body matrix elements via the one- and two-particle matrix elements of the underlying single-particle basis.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#constructing-updates","page":"CPIMC.jl","title":"constructing updates","text":"","category":"section"},{"location":"cpimc/","page":"CPIMC.jl","title":"CPIMC.jl","text":"Step\napply_step\napply_step!\nadd_orbs\nadd_orbs!\ndrop_orbs\ndrop_orbs!\nadd_kinks\nadd_kinks!\nremove_kinks\nremove_kinks!\nUpdateCounter","category":"page"},{"location":"cpimc/#CPIMC.Step","page":"CPIMC.jl","title":"CPIMC.Step","text":"Represents a change which can be applied to a Configuration.\n\nFields\n\ndrop_orbs  – Orbitals which are to be removed from the initial occupation\ndrop_kinks – pairs of ImgTime and Kinks which are to be removed\nadd_orbs   – Orbitals which are added to the initial occupation\nadd_kinks  – pairs of ImgTime and Kinks which are added\n\n\n\n\n\n","category":"type"},{"location":"cpimc/#CPIMC.apply_step","page":"CPIMC.jl","title":"CPIMC.apply_step","text":"apply_step(c::Configuration, step::Step)\napply_step(c::Configuration, steps)\n\nReturn the result of applying the changes given by the second argument to a Configuration.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.apply_step!","page":"CPIMC.jl","title":"CPIMC.apply_step!","text":"apply_step!(c::Configuration, step::Step)\napply_step!(c::Configuration, steps)\n\nApply the changes given by the second argument to a Configuration.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.UpdateCounter","page":"CPIMC.jl","title":"CPIMC.UpdateCounter","text":"Objects of this type are used to keep track of the acceptance ratio of a class of updates.\n\nFields\n\nrejected – number of times updates have been rejected\naccepted – number of times updates have been accepted\ntrivial  – number of times the changes proposed by updates of that class have been trivial, e.g. the Step returned by update has been empty\n\nFor convenience, an outer constructor with all counters set to zero is provided:\n\nUpdateCounter() = UpdateCounter(0,0,0)\n\n\n\n\n\n","category":"type"},{"location":"cpimc/#utility-functions","page":"CPIMC.jl","title":"utility functions","text":"","category":"section"},{"location":"cpimc/","page":"CPIMC.jl","title":"CPIMC.jl","text":"time_ordered_orbs\nkinks_affecting_orbs\nadjacent_kinks\nadjacent_kinks_affecting_orbs\nτ_prev_affecting\nτ_next_affecting\nτ_borders\nprev\nnext\nprev_affecting\nnext_affecting\nisunaffected\nisunaffected_in_interval","category":"page"},{"location":"cpimc/#CPIMC.time_ordered_orbs","page":"CPIMC.jl","title":"CPIMC.time_ordered_orbs","text":"time_ordered_orbs(ck::Kinks{T}) where {T <: Orbital}\n\nGet a list of orbitals that affect each kink in the time-ordering of the kinks and in the conventional ordering i, j, k, l.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.kinks_affecting_orbs","page":"CPIMC.jl","title":"CPIMC.kinks_affecting_orbs","text":" kinks_affecting_orbs(itr::Any, itr::Any)\n\nReturn all kinks in the first argument that affect one ore more of the orbitals the second argument. The first itr is expected to contain tuples or at least types on which last() is defined and last(i) is intended to contain a ::T4 for all elements i ∈ itr or at least a type which has fields with the names i, j, k, l.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.adjacent_kinks","page":"CPIMC.jl","title":"CPIMC.adjacent_kinks","text":"adjacent_kinks(itr::Any, ::Any)\n\nReturn a tuple of the kink in itr that is closest right of the time in the second argument. This expects that methods for the functions next() and prev() are defined for the given argument types. Used for getting a tuple of the neighbouring kinks from some imaginary time.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.adjacent_kinks_affecting_orbs","page":"CPIMC.jl","title":"CPIMC.adjacent_kinks_affecting_orbs","text":"adjacent_kinks_affecting_orbs(::Any, ::Any, ::Any)\n\nReturn a tuple of the closest kink to the right and the closest kink to the left of some imaginary time that affect one of the orbitals in some collection. If there are no such kinks, return (nothing,nothing). The first argument is expected to be an iterable which contains pairs as elements, with the first element of each pair containing an imaginary time and the second element of each pair containing a kink. The second argument is expected to be a collection of orbitals, that are to be considered regarding affection with one of the kinks in the first argument. The third argument is expected to be an imaginary time from which the neighbouring kinks affected by any orbitals from the second argument are to be determined.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.τ_prev_affecting","page":"CPIMC.jl","title":"CPIMC.τ_prev_affecting","text":" τ_prev_affecting(::Any, ::Any, ::Any)\n\nReturn the ImgTime of the closest kink to the left of τ that affects one of the orbitals in os.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.τ_next_affecting","page":"CPIMC.jl","title":"CPIMC.τ_next_affecting","text":" τ_next_affecting(::Any, ::Any, ::Any)\n\nReturn the ImgTime of the closest kink to the right of τ that affects one of the orbitals in os.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.τ_borders","page":"CPIMC.jl","title":"CPIMC.τ_borders","text":" τ_borders(::Kinks{T}, orbs, ::ImgTime) where {T <: Orbital}\n\nReturn a tuple of the ImgTime of the closest kink to the right and the ImgTime of the closest kink to the left of τ that affect one of the orbitals in orbs. If no orbital in os is affected by and kink from the collection in the first argument, return a tuple of the interval bounds (ImgTime(0), ImgTime(1)).\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.prev_affecting","page":"CPIMC.jl","title":"CPIMC.prev_affecting","text":" prev_affecting(a::Any, orbs::Any, τ::Any)\n\nReturn the index of the closest kink to the left of τ that affects one of the orbitals in orbs. If no orbital in orbs is affected by any kink return 0.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.next_affecting","page":"CPIMC.jl","title":"CPIMC.next_affecting","text":" next_affecting(a::Any, orbs::Any, τ::Any)\n\nReturn the index of the closest kink to the right of τ that affects one of the orbitals in orbs. If no orbital in orbs is affected by any kink return 0.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.isunaffected","page":"CPIMC.jl","title":"CPIMC.isunaffected","text":"isunaffected(Kinks, orb)\n\nReturn if an orbital is not affected by any kink.\n\n\n\n\n\n","category":"function"},{"location":"cpimc/#CPIMC.isunaffected_in_interval","page":"CPIMC.jl","title":"CPIMC.isunaffected_in_interval","text":"isunaffected_in_interval(kinks, orb, τ_first::ImgTime, τ_last::ImgTime)\n\nReturn if an orbital is not affected by any of the kinks from ck in the open interval (τ_first,τ_last).\n\n\n\n\n\n","category":"function"},{"location":"estimators/#Estimators","page":"Estimators","title":"Estimators","text":"","category":"section"},{"location":"estimators/","page":"Estimators","title":"Estimators","text":"This module provides a collection of estimators which are independent of the physical system.","category":"page"},{"location":"estimators/","page":"Estimators","title":"Estimators","text":"CurrentModule = CPIMC.Estimators","category":"page"},{"location":"estimators/","page":"Estimators","title":"Estimators","text":"Modules = [CPIMC.Estimators]","category":"page"},{"location":"estimators/#CPIMC.Estimators","page":"Estimators","title":"CPIMC.Estimators","text":"generic estimators for the CPIMC formalism\n\n\n\n\n\n","category":"module"},{"location":"estimators/#CPIMC.Estimators.E-Tuple{Model,Ensemble,Configuration}","page":"Estimators","title":"CPIMC.Estimators.E","text":"E(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the interaction energy This estimator is redundant because we can calculate the full energy as the sum of the kinetic and the interaction part.\n\n\n\n\n\n","category":"method"},{"location":"estimators/#CPIMC.Estimators.Ekin-Tuple{Model,Ensemble,Configuration}","page":"Estimators","title":"CPIMC.Estimators.Ekin","text":"Ekin(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the kinetic energy\n\n\n\n\n\n","category":"method"},{"location":"estimators/#CPIMC.Estimators.K-Tuple{Model,Ensemble,Configuration}","page":"Estimators","title":"CPIMC.Estimators.K","text":"K(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the number of kinks\n\n\n\n\n\n","category":"method"},{"location":"estimators/#CPIMC.Estimators.W-Tuple{Model,Ensemble,Configuration}","page":"Estimators","title":"CPIMC.Estimators.W","text":"W(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the interaction energy This estimator is redundant because we can calculate the interaction energy from Kfermion and Wdiag.\n\n\n\n\n\n","category":"method"},{"location":"estimators/#CPIMC.Estimators.W_diag-Tuple{Model,Ensemble,Configuration}","page":"Estimators","title":"CPIMC.Estimators.W_diag","text":"W_diag(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the diagonal contribution to the interaction energy\n\n\n\n\n\n","category":"method"},{"location":"estimators/#CPIMC.Estimators.W_off_diag-Tuple{Model,Ensemble,Configuration}","page":"Estimators","title":"CPIMC.Estimators.W_off_diag","text":"W_off_diag(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the offdiagonal contribution to the interaction energy This estimator is redundant because we can calculate the offdiagonal interaction energy from K_fermion.\n\n\n\n\n\n","category":"method"},{"location":"estimators/#CPIMC.Estimators.occupations","page":"Estimators","title":"CPIMC.Estimators.occupations","text":"occupations(m::Model, e::Ensemble, c::Configuration, emax::Int=100) :: Array{Float64,1}\n\nestimator for the occupations of the emax:Int lowest single particle energy eigenvalues\n\n\n\n\n\n","category":"function"},{"location":"estimators/#CPIMC.signum-Tuple{Model,Ensemble,Configuration}","page":"Estimators","title":"CPIMC.signum","text":"signum(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the sign of the weight function\n\n\n\n\n\n","category":"method"},{"location":"#CPIMC2020","page":"Home","title":"CPIMC2020","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"New implementation of Configuration path-integral Monte Carlo (CPIMC) written in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Compared to other implementations we put particular emphasis on flexibility. The goal of this project is to provide an environment for trying out new ideas that is both easy to use and extend.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"full CPIMC simulation for the uniform electron gas using a plane waves basis\nno artificial restriction on the number of basis functions\nno explicit ordering of orbitals required\nmulti-threading","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A full description of the formalism can be found in Tim Schoof's PhD thesis[1]. For a more modern perspective which is closer to this implementation one should also consider Kai Hunger's Master thesis [WIP].","category":"page"},{"location":"","page":"Home","title":"Home","text":"As a gentle introduction we prepared a guided implementation of the ideal Fermi gas in examples/ideal.jl which should get you accustomed to the core functionality of this package. This should prepare you to explore on your own how the model of the uniform electron gas is realized in src/UniformElectronGas.jl.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Schoof, T. (2016). Configuration Path Integral Monte Carlo: Ab initio simulations of fermions in the warm dense matter regime [PhD thesis, CAU Kiel] https://d-nb.info/1133492177/34","category":"page"},{"location":"ueg/#UniformElectronGas","page":"UniformElectronGas","title":"UniformElectronGas","text":"","category":"section"},{"location":"ueg/","page":"UniformElectronGas","title":"UniformElectronGas","text":"CurrentModule = CPIMC.UniformElectronGas","category":"page"},{"location":"ueg/","page":"UniformElectronGas","title":"UniformElectronGas","text":"CPIMC.UniformElectronGas","category":"page"},{"location":"ueg/#CPIMC.UniformElectronGas","page":"UniformElectronGas","title":"CPIMC.UniformElectronGas","text":"Types and definitions used for simulations of the uniform electron gas.\n\n\n\n\n\n","category":"module"},{"location":"ueg/#Model","page":"UniformElectronGas","title":"Model","text":"","category":"section"},{"location":"ueg/","page":"UniformElectronGas","title":"UniformElectronGas","text":"UEG\nw(m::UEG, o1::Orbital, o2::Orbital, o3::Orbital, o4::Orbital)\nenergy(m::UEG, o::PlaneWave)","category":"page"},{"location":"ueg/#CPIMC.UniformElectronGas.UEG","page":"UniformElectronGas","title":"CPIMC.UniformElectronGas.UEG","text":"Singleton for dispatching.\n\nFor other models this would be the place to store additional parameters that might come up in the matrix elements.\n\n\n\n\n\n","category":"type"},{"location":"ueg/#CPIMC.w-Tuple{CPIMC.UniformElectronGas.UEG,Orbital,Orbital,Orbital,Orbital}","page":"UniformElectronGas","title":"CPIMC.w","text":"w(i::Orbital, j::Orbital, k::Orbital, l::Orbital)\n\nReturn the two-particle matrix element of the Coulomb interaction. Zero is returned if momentum or spin is not conserved, in consequence of the Bloch-theorem and the spin kronecker-delta in the plane-spin-wave basis.\n\nThe singular contribution (i.vec == k.vec) is also removed, i.e. set to zero. This property is not a result of the Bloch theorem for the two-particle Coulomb matrix element in the plane wave basis but is added here to allow for straightforward summation over all combination of orbitals without explictly excluding this component.\n\nIt is not part of the UEG many-body Hamiltonian due to the physical assumption that contributions from the uniform background cancel with this diverging term in the thermodynamic limit.\n\n\n\n\n\n","category":"method"},{"location":"ueg/#CPIMC.energy-Tuple{CPIMC.UniformElectronGas.UEG,CPIMC.PlaneWaves.PlaneWave}","page":"UniformElectronGas","title":"CPIMC.energy","text":"energy(m::UEG, o::PlaneWave)\n\nThe single-particle energy of a plane wave with momentum veck is given by (Hartree atomic units):\n\n$ \\epsilon_k = \\vec{k}^2 / 2. $\n\nIn the internal unit system we use integer k-values, which results in:\n\n$ \\epsilon_k = \\vec{k}^2. $\n\n\n\n\n\n","category":"method"},{"location":"ueg/#Units","page":"UniformElectronGas","title":"Units","text":"","category":"section"},{"location":"ueg/","page":"UniformElectronGas","title":"UniformElectronGas","text":"λ\nrs\ninternal_energy_factor\nkF\nEF\nβ_Ha\nβ","category":"page"},{"location":"ueg/#CPIMC.UniformElectronGas.λ","page":"UniformElectronGas","title":"CPIMC.UniformElectronGas.λ","text":"λ(N, rs, d::Int)\n\ncalculate λ, which is the coupling constant of the Hamiltonian in internal units from the particle number N, Bruecker parameter rs for the density and spatial dimension d the differences for d ∈ {2,3} reflect the different expressions for the Coulomb interaction, whichs Fourier component is vq = \frac{4π}{q^2} in 3D and vq = \frac{2π}{q} in 2D the one-dimensional case involves a short-distance cutoff to avoid the non-integrable divergence of the interaction at zero distance and is not implemented\n\n\n\n\n\n","category":"function"},{"location":"ueg/#CPIMC.UniformElectronGas.rs","page":"UniformElectronGas","title":"CPIMC.UniformElectronGas.rs","text":"rs(N, λ, d::Int)\n\ncalculate the Brueckner parameter rs for the density from the particle number N and λ, which is the coupling constant of the Hamiltonian in internal units\n\n\n\n\n\n","category":"function"},{"location":"ueg/#CPIMC.UniformElectronGas.internal_energy_factor","page":"UniformElectronGas","title":"CPIMC.UniformElectronGas.internal_energy_factor","text":"internal_energy_factor(N, rs, d)\n\nThis factor is used to convert an energy quantity from Hartree a.u. to internal units. A value of the quantity in Hartree a.u. has to be multiplied by this factor to yield the corresponding value of the quantity in internal units. A value of the quantity in internal units has to be divided by this factor to yield the corresponding value of the quantity in Hartree a.u.\n\n\n\n\n\n","category":"function"},{"location":"ueg/#CPIMC.UniformElectronGas.kF","page":"UniformElectronGas","title":"CPIMC.UniformElectronGas.kF","text":"kF(rs, ξ, d::Int)\n\ncalculate the Fermi wavenumber in Hartree a.u. from Brueckner parameter rs for the density, the fractional spin polarization ξ and spatial dimension d\n\n\n\n\n\n","category":"function"},{"location":"ueg/#CPIMC.UniformElectronGas.EF","page":"UniformElectronGas","title":"CPIMC.UniformElectronGas.EF","text":"EF(rs, ξ, d::Int)\n\ncalculate the Fermi energy in Hartree a.u. from Brueckner parameter rs for the density, the fractional spin polarization ξ and spatial dimension d\n\n\n\n\n\n","category":"function"},{"location":"ueg/#CPIMC.UniformElectronGas.β_Ha","page":"UniformElectronGas","title":"CPIMC.UniformElectronGas.β_Ha","text":"β_Ha(Θ, EF)\n\ncalculate the inverse temperature in Hartree a.u. from the reduced temperature Θ and the Fermi energy EF in Hartree a.u. the inverse temperature is defined by β = 1 / (kB*T) where kB is the Boltzmann constant and T is the temperature\n\n\n\n\n\n","category":"function"},{"location":"ueg/#CPIMC.UniformElectronGas.β","page":"UniformElectronGas","title":"CPIMC.UniformElectronGas.β","text":"β(Θ, rs, N, ξ, d::Int)\n\ncalculate β in internal units\n\n\n\n\n\n","category":"function"}]
}

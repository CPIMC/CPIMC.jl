var documenterSearchIndex = {"docs":
[{"location":"api/#CPIMC","page":"API reference","title":"CPIMC","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [CPIMC]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"api/#Base.:+-Tuple{UpdateCounter,UpdateCounter}","page":"API reference","title":"Base.:+","text":"Base.:+(x::UpdateCounter, y::UpdateCounter)\n\nAddition of counters for example to add counters from different Markov-chains.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Union{Tuple{T}, Tuple{Array{Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}},1},Fixed{Int64,60}}} where T","page":"API reference","title":"Base.getindex","text":"Base.getindex(kinks::Kinks{T}, τ::ImgTime) where {T}\n\nAllow the kinks[τ]-syntax to retrieve a Kink at a specific ImgTime.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey-Tuple{Array{Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}},1} where T,Fixed{Int64,60}}","page":"API reference","title":"Base.haskey","text":"Base.haskey(ck::Kinks, key::ImgTime)\n\nCheck if a Kinks-object contains a kink at a specific time.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.Woffdiag_element-Tuple{Model,Ensemble,Orbital,Orbital,Orbital,Orbital}","page":"API reference","title":"CPIMC.Woffdiag_element","text":"Woffdiag_element(::Model, ::Ensemble, ::Orbital, ::Orbital, ::Orbital, ::Orbital)\n\nReturn the offdiagonal many body matrix element of the interaction operator\n\nfrac14 ( w_ijkl - w_ijlk ) (pm langletildenn^ij_klrangle)\n\nfor an excitation given by creating orbitals i,j and annihilating orbitals k, l as given by the Slater-Condon rules.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.add_kinks!-Tuple{Array{Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}},1} where T,Nothing}","page":"API reference","title":"CPIMC.add_kinks!","text":"add_kinks!(ck::Kinks, s)\n\nAdd the kinks in s to ck.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.add_kinks-Tuple{Array{Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}},1} where T,Nothing}","page":"API reference","title":"CPIMC.add_kinks","text":"add_kinks(ck::Kinks, s)\n\nReturn a copy of the kinks in ck with the kinks in s added.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.add_orbs!-Tuple{Any,Nothing}","page":"API reference","title":"CPIMC.add_orbs!","text":"add_orbs!(occ, s)\n\nAdd the orbitals in s to the occupation occ.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.add_orbs-Tuple{Any,Nothing}","page":"API reference","title":"CPIMC.add_orbs","text":"add_orbs(occ, orbs)\n\nReturn a copy of the occupation occ with the orbitals in orbs added.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.adjacent_kinks-Tuple{Any,Any}","page":"API reference","title":"CPIMC.adjacent_kinks","text":"adjacent_kinks(itr::Any, ::Any)\n\nReturn a tuple of the kink in itr that is closest right of the time in the second argument. This expects that methods for the functions next() and prev() are defined for the given argument types. Used for getting a tuple of the neighbouring kinks from some imaginary time.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.adjacent_kinks_affecting_orbs-Tuple{Any,Any,Any}","page":"API reference","title":"CPIMC.adjacent_kinks_affecting_orbs","text":"adjacent_kinks_affecting_orbs(::Any, ::Any, ::Any)\n\nReturn a tuple of the closest kink to the right and the closest kink to the left of some imaginary time that affect one of the orbitals in some collection. If there are no such kinks, return (nothing,nothing). The first argument is expected to be an iterable which contains pairs as elements, with the first element of each pair containing an imaginary time and the second element of each pair containing a kink. The second argument is expected to be a collection of orbitals, that are to be considered regarding affection with one of the kinks in the first argument. The third argument is expected to be an imaginary time from which the neighbouring kinks affected by any orbitals from the second argument are to be determined.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.annihilators-Tuple{T4}","page":"API reference","title":"CPIMC.annihilators","text":"annihilators(x::T4)\n\nreturn a set of the two annihilators which are affected by a T4 kink\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.apply_step!-Tuple{Configuration,Step}","page":"API reference","title":"CPIMC.apply_step!","text":"apply_step!(c::Configuration, step::Step)\napply_step!(c::Configuration, steps)\n\nApply the changes given by the second argument to a Configuration.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.apply_step-Tuple{Configuration,Any}","page":"API reference","title":"CPIMC.apply_step","text":"apply_step(c::Configuration, step::Step)\napply_step(c::Configuration, steps)\n\nReturn the result of applying the changes given by the second argument to a Configuration.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.basis-Union{Tuple{Configuration{T}}, Tuple{T}} where T","page":"API reference","title":"CPIMC.basis","text":"basis(c::Configuration{T})\n\nReturn type parameter T of the configuration.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.creators-Tuple{T4}","page":"API reference","title":"CPIMC.creators","text":"creators(::T4)\n\nreturn a set of the two creators which are affected by a T4 kink\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.drop_kinks!-Tuple{Any,Nothing}","page":"API reference","title":"CPIMC.drop_kinks!","text":"drop_kinks!(ck, s)\n\nRemove the kinks in s from ck.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.drop_kinks-Tuple{Any,Nothing}","page":"API reference","title":"CPIMC.drop_kinks","text":"drop_kinks(ck, s)\n\nReturn a copy of the kinks in ck without the kinks in s.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.drop_orbs!-Tuple{Any,Nothing}","page":"API reference","title":"CPIMC.drop_orbs!","text":"drop_orbs!(occ, s)\n\nRemove the orbitals in s from the occupation occ.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.drop_orbs-Tuple{Any,Nothing}","page":"API reference","title":"CPIMC.drop_orbs","text":"drop_orbs(occ, orbs)\n\nReturn a copy of the occupation occ without the orbitals in orbs.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.excitations-Tuple{Array{Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}},1} where T}","page":"API reference","title":"CPIMC.excitations","text":"excitations(ck::Kinks)\n\nReturn a list of the excitations of a Kinks-object, used to allow the use of dictionary syntax.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.excite!-Union{Tuple{T}, Tuple{Set{T},T,T,T,T}} where T","page":"API reference","title":"CPIMC.excite!","text":"excite!(::Set{T}, i::T, j::T, k::T, l::T) where {T}\nexcite!(o::Set{T}, κ::T4{T})\n\nApply an excitation in-place to a set of basis states that is given by creating orbitals i, j and annihilating the orbitals k, l.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.excite-Union{Tuple{T}, Tuple{Set{T},Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}}}} where T","page":"API reference","title":"CPIMC.excite","text":"excite(o::Set{T}, κ::Pair{ImgTime,T4{T}})\n\nApply a T4-kink to a set of basis states for a pair of a time and a T4-kink. This is useful for iterating over a Kinks-object when calculating the occupations at a specific time.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.excite-Union{Tuple{T}, Tuple{Set{T},T4{T}}} where T","page":"API reference","title":"CPIMC.excite","text":"excite(::Set{T}, ::T4{T})\n\nApply a kink to a set of basis states, i.e. return a set of basis states where the states specified by the creators of the kink are added and the states specified by the annihilators of the kink are dropped from the given set of basis states. This has the physical meaning of a two-particle scattering event where two (quasi-)particles in a many-body state change the single-particle states they occupy. In occupation number representation this reads\n\na^dagger_i a^dagger_j a_k a_l nrangle\n\nfor creator orbitals i and j and annihilator orbitals k and l. This function assumes fermionic particle statistics (Pauli principle),\n\na^dagger_i a^dagger_i = a_i a_i = 0\n\ni.e. the target (creator) states must not be occupied and the initial (annihilator) states must be occupied in the given set of states.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.in_open_interval-Tuple{Any,Any,Any}","page":"API reference","title":"CPIMC.in_open_interval","text":"in_open_interval(τ, τ_first, τ_last)\n\nCheck if τ lies in the open ImgTime-interval (τ_first,τlast), assuming thatτfirstis the left border andτ_last` the right one.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.is_type_1-Tuple{T4,T4}","page":"API reference","title":"CPIMC.is_type_1","text":"is_type_1(left_kink::T4, right_kink::T4)\n\nReturns True if leftkink and rightkink are entangled in a Type-1 way. This does not check wether the two kinks are neighbouring.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.isunaffected-Tuple{Any,Any}","page":"API reference","title":"CPIMC.isunaffected","text":"isunaffected(Kinks, orb)\n\nReturn if an orbital is not affected by any kink.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.isunaffected_in_interval-Tuple{Any,Any,Fixed{Int64,60},Fixed{Int64,60}}","page":"API reference","title":"CPIMC.isunaffected_in_interval","text":"isunaffected_in_interval(kinks, orb, τ_first::ImgTime, τ_last::ImgTime)\n\nReturn if an orbital is not affected by any of the kinks from ck in the open interval (τ_first,τ_last).\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.kinks_affecting_orbs-Tuple{Any,Any}","page":"API reference","title":"CPIMC.kinks_affecting_orbs","text":" kinks_affecting_orbs(itr::Any, itr::Any)\n\nReturn all kinks in the first argument that affect one ore more of the orbitals the second argument. The first itr is expected to contain tuples or at least types on which last() is defined and last(i) is intended to contain a ::T4 for all elements i ∈ itr or at least a type which has fields with the names i, j, k, l.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.kinks_from_periodic_interval-Tuple{Array{Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}},1} where T,Any,Any}","page":"API reference","title":"CPIMC.kinks_from_periodic_interval","text":"kinks_from_periodic_interval(::Kinks, τ1, τ2)\n\nreturn kinks with τ ∈ (τ1,τ2) if τ1 < τ2 and τ ∈ (τ2,1) ∪ (0,τ1) if τ1 > τ2\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.ladder_operator_order_factor-Tuple{Array{#s14,1} where #s14<:Orbital}","page":"API reference","title":"CPIMC.ladder_operator_order_factor","text":"ladder_operator_order_factor(sortedlist::Array{<:Orbital,1})\n\nReturns 1 or -1 depending on the order of all ladder operators as given by a list of orbitals.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.ladder_operator_order_factor-Tuple{Array{Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}},1} where T}","page":"API reference","title":"CPIMC.ladder_operator_order_factor","text":"ladder_operator_order_factor(ck::Kinks)\n\nReturns 1 or -1 depending on the order of all ladder operators as given by the orbitals that affect each kink in the time-ordering of the kinks and in the conventional ordering i, j, k, l, used in the sign estimator.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.left_type_1_chain_length","page":"API reference","title":"CPIMC.left_type_1_chain_length","text":"left_type_1_chain_length(ck::Kinks, τ, counted_τs = [])\n\nReturns the length of the chain of type-1-entaglements starting with the Kink at τ counting to the left.\n\n\n\n\n\n","category":"function"},{"location":"api/#CPIMC.longest_type_1_chain_length-Tuple{Array{Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}},1} where T}","page":"API reference","title":"CPIMC.longest_type_1_chain_length","text":"longest_type_1_chain_length(ck::Kinks)\n\nReturns the longest chain of type-1-entaglements in ck.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.measure!-NTuple{4,Any}","page":"API reference","title":"CPIMC.measure!","text":"measure!(m::Model, e::Ensemble, c::Configuration, estimators)\n\nPerform measurements on a Configuration. estimators needs to be a dictionary that contains tuples (::OnlineStat, ::Function).\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.next-Tuple{Any,Any}","page":"API reference","title":"CPIMC.next","text":"next(a, τ)\n\nReturn index of the first kink after to the given τ. If there is no kink with ::ImgTime larger than τ, return index of first kink. Throw a DomainError if an empty list is passed as first argument.\n\nThis function assumes that the kinks in a are ordered with respect to their imaginary time!\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.next_affecting-Tuple{Any,Any,Any}","page":"API reference","title":"CPIMC.next_affecting","text":" next_affecting(a::Any, orbs::Any, τ::Any)\n\nReturn the index of the closest kink to the right of τ that affects one of the orbitals in orbs. If no orbital in orbs is affected by any kink return 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.occupations_at-Tuple{Configuration,Fixed{Int64,60}}","page":"API reference","title":"CPIMC.occupations_at","text":"occupations_at(c::Configuration, τ::ImgTime)\n\nReturn the occupied orbitals to the right of τ.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.occupations_at-Union{Tuple{T}, Tuple{Set{T},Array{Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}},1}}} where T","page":"API reference","title":"CPIMC.occupations_at","text":"occupations_at(o::Set{T}, kinks::Kinks{T})\n\nReturn the occupied orbitals after applying all kinks to initial occupation.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.orbs-Tuple{T2}","page":"API reference","title":"CPIMC.orbs","text":"orbs(::T2)\n\nReturn a Tuple of all orbitals that are affected by a T2-kink in the conventional ordering i, j.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.orbs-Tuple{T4}","page":"API reference","title":"CPIMC.orbs","text":"orbs(::T4)\n\nReturn a Tuple of all orbitals that are affected by a T4-kink in the conventional ordering i, j, k, l. This corresponds to the matrix element w_ijkl in the same order.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.prev-Tuple{Any,Any}","page":"API reference","title":"CPIMC.prev","text":"prev(a, τ)\n\nReturn the index of the first kink earlier than τ::ImgTime. If there is no such kink the last kink is returned. Throw a DomainError if an empty list is passed as first argument.\n\nThis function assumes that the kinks in x are ordered with respect to their imaginary time!\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.prev_affecting-Tuple{Any,Any,Any}","page":"API reference","title":"CPIMC.prev_affecting","text":" prev_affecting(a::Any, orbs::Any, τ::Any)\n\nReturn the index of the closest kink to the left of τ that affects one of the orbitals in orbs. If no orbital in orbs is affected by any kink return 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.print_rates-Tuple{Any}","page":"API reference","title":"CPIMC.print_rates","text":"print_rates(dict::Dict{Any,UpdateCounter})\n\nCalculate and print acceptance statistics.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.print_results-Tuple{Any,Ensemble}","page":"API reference","title":"CPIMC.print_results","text":"print_results(measurements, e::Ensemble)\n\nPrint all measured observables, potentially taking the sign into account.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.random_shuffle-Tuple{Any,Any}","page":"API reference","title":"CPIMC.random_shuffle","text":"random_shuffle(::Any, ::Any)\n\nshuffle or not shuffle the given tuple with equal propability: Return either the same tuple, or the tuple in reverse order, with equal probability 0.5.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.right_type_1_chain_length","page":"API reference","title":"CPIMC.right_type_1_chain_length","text":"right_type_1_chain_length(ck, τ, count = 0)\n\nReturns the length of the chain of type-1-entaglements starting with the Kink at τ counting to the right.\n\n\n\n\n\n","category":"function"},{"location":"api/#CPIMC.right_type_1_count-Tuple{Array{Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}},1} where T}","page":"API reference","title":"CPIMC.right_type_1_count","text":"right_type_1_count(ck::Kinks)\n\nReturns the number of kinks that are type 1 entagled with their right neighbour.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.shuffle_annihilators-NTuple{4,Any}","page":"API reference","title":"CPIMC.shuffle_annihilators","text":"shuffle_annihilators(::Any, ::Any, ::Any, ::Any)\n\nReturn a tuple where the last two arguments are randomly shuffled with equal probability 0.5 in comparison to the ordering of the input.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.shuffle_creators-NTuple{4,Any}","page":"API reference","title":"CPIMC.shuffle_creators","text":"shuffle_creators(::Any, ::Any, ::Any, ::Any)\n\nReturn a tuple where the first two arguments are randomly shuffled with equal probability 0.5 in comparison to the ordering of the input.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.shuffle_indices-NTuple{4,Any}","page":"API reference","title":"CPIMC.shuffle_indices","text":"shuffle_indices(::Any, ::Any, ::Any, ::Any)\n\nReturn a tuple where both the first two arguments and the last two arguments are randomly shuffled with equal probability 0.5 respectively in comparison to the ordering of the input.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.sign_offdiagonal_product-Tuple{Model,Configuration}","page":"API reference","title":"CPIMC.sign_offdiagonal_product","text":"sign_offdiagonal_product(::Model, ::Configuration)\n\nReturn the sign of the product of two-particle terms in the offdiagonal many-body matrix elements. These are given by function wminus, i.e.\n\nlangle tilden  a^dagger_i a^dagger_j a_k a_l  n rangle\n    = pm ( w_ijkl - w_ijlk ) text for  tilden = n_kl^ij\n\nthe term in the braces may be negative and this function returns the product of the sign of all these contributions w_ijkl - w_ijlk from all kinks. The sign pm is determined from the permutation factor of the orbitals i,j,k,l and is not calculated here.\n\nused for the calculation the sign of the weight function\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.signum-Tuple{Model,Configuration}","page":"API reference","title":"CPIMC.signum","text":"signum(m::Model, c::Configuration)\n\nCalculate the sign of the Configuration's weight.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.sweep!-Tuple{Model,Ensemble,Configuration,Any,Any,Int64,Int64,Int64}","page":"API reference","title":"CPIMC.sweep!","text":"sweep!(m::Model, e::Ensemble, c::Configuration, updates, estimators, steps::Int, sampleEvery::Int, throwAway::Int)\n\nGenerate a markov chain of length steps using the Metropolis-Hastings algorithm with the updates given in updates. After throwAway steps have been performed, the observables given in estimators are calculated every sampleEvery steps.\n\nReturns a dictionary containing an UpdateCounter for every function given in updates.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.time_ordered_orbs-Union{Tuple{Array{Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}},1}}, Tuple{T}} where T<:Orbital","page":"API reference","title":"CPIMC.time_ordered_orbs","text":"time_ordered_orbs(ck::Kinks{T}) where {T <: Orbital}\n\nGet a list of orbitals that affect each kink in the time-ordering of the kinks and in the conventional ordering i, j, k, l.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.times-Tuple{Array{Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}},1} where T}","page":"API reference","title":"CPIMC.times","text":"times(ck::Kinks)\n\nReturn a list of the imaginary-times of a Kinks-object, used to allow the use of dictionary syntax.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.times_from_periodic_interval-Tuple{Array{Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}},1} where T,Fixed{Int64,60},Fixed{Int64,60}}","page":"API reference","title":"CPIMC.times_from_periodic_interval","text":"times_from_periodic_interval(::Kinks, ::ImgTime, ::ImgTime)\n\nreturn a list of all times of kinks with τ ∈ (τ1,τ2) if τ1 < τ2 or τ ∈ (τ2,1) ∪ (0,τ1) if τ1 > τ2 in the periodic ordering suggested by the relation of the first time-argument τ1 to the second time-argument τ2\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.update!-Tuple{Model,Ensemble,Configuration,Any}","page":"API reference","title":"CPIMC.update!","text":"update!(m::Model, e::Ensemble, c::Configuration, updates)\n\nObtain the next state of the Markov chain by randomly selecting an element of updates and applying the proposed changes to c with the calculated probability. Returns a tuple containing the index of the chosen function and :accept, :reject or :trivial if the function yielded an empty Step.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.wminus-Tuple{Model,Any,Any,Any,Any}","page":"API reference","title":"CPIMC.wminus","text":"wminus(::Model, i,j,k,l)\n\nreturn the difference of the two-particle matrix element with the same but the last two indices transposed antisymmetric difference of the two-particle matrix elements:\n\nw^-_ijkl = w_ijkl - w_ijlk\n\nThis is called the antisymmetrized two-particle matrix element. This is an abbreviation for these terms arising in the Slater-Condon rules for the calculation of the many-body matrix elements via the one- and two-particle matrix elements of the underlying single-particle basis.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.Δ-Tuple{Fixed{Int64,60},Fixed{Int64,60}}","page":"API reference","title":"CPIMC.Δ","text":"Δ(::ImgTime,::ImgTime)\n\nreturn the length of the periodic interval between the two ::ImgTimes\n\nthe periodic distance of two imaginary times:\n\n`Δ(τ1,τ2) = τ2 - τ1` if `τ2 >= τ1` and\n`Δ(τ1,τ2) = 1 - (τ1 - τ2) = 1 + τ2 - τ1` else\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.ΔT_element-Tuple{Model,Any,Any,Any,Any}","page":"API reference","title":"CPIMC.ΔT_element","text":"ΔT_element(::Model, i,j,k,l)\n\nreturn the change in the kinetic many body matrix element due to creating orbitals i, j and annihilating orbitals k, l\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.ΔW_diag-Tuple{Model,Any,Any,Any,Any,Any}","page":"API reference","title":"CPIMC.ΔW_diag","text":"ΔW_diag(m::Model, i, j, k, l, occ)\n\nchange in the diagonal interaction matrix element due to a change in the occupation occ in a periodic interval (τ1,τ2) where no kinks occur the change in the occupation is assumed to consist in a creation of two orbitals i, j and in the annihlation of two orbitals k, l\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.ΔW_diag-Tuple{Model,Any,Any,Any}","page":"API reference","title":"CPIMC.ΔW_diag","text":"ΔW_diag(m::Model, i, j, occ)\n\nchange in the diagonal interaction matrix element due to a change in the occupation occ in a periodic interval (τ1,τ2) where no kinks occur the change in the occupation is assumed to consist in a creation of one orbitals i and in the annihlation of one orbitals j\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.ΔWdiag_element-Tuple{Model,Ensemble,Configuration,Any,Any,Any,Any,Any,Any}","page":"API reference","title":"CPIMC.ΔWdiag_element","text":"ΔWdiag_element(::Model, ::Ensemble, ::Configuration, i, j, k, l, τ1, τ2)\n\nCalculate the change in the diagonal interaction many-body matrix element due to a change in the occupations given by creating two orbitals i and j and annihilating two orbitals k, l in the interval (τ1, τ2). This interval may be periodically extended over the bounds (0,1) if τ1 > τ2, i.e. the change in the occupation is considered for (τ1,1] ∪ [0,τ2) in that case. We do not need to evaluate the diagonal interaction between all orbitals in all time-intervalls, but it is sufficient to evaluate the full diagonal interaction with the occupations at the start of the intervall and then consider only contributions of orbitals that are changed by kinks in the intervall.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.ΔWdiag_element-Tuple{Model,Ensemble,Configuration,Any,Any,Any,Any}","page":"API reference","title":"CPIMC.ΔWdiag_element","text":"ΔWdiag_element(::Model, ::Ensemble, ::Configuration, i, j, τ1, τ2)\n\nCalculate the change in the diagonal interaction many-body matrix element due to a change in the occupations given by creating an orbital i and annihilating an orbital j in the interval (τ1, τ2). This interval may be periodically extended over the bounds (0,1) if τ1 > τ2, i.e. the change in the occupation is considered for (τ1,1] ∪ [0,τ2) in that case. We do not need to evaluate the diagonal interaction between all orbitals in all time-intervalls, but it is sufficient to evaluate the full diagonal interaction with the occupations at the start of the intervall and then consider only contributions of orbitals that are changed by kinks in the intervall.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.ΔWoffdiag_element-Tuple{Model,Ensemble,Any,Any}","page":"API reference","title":"CPIMC.ΔWoffdiag_element","text":"ΔWoffdiag_element(::Model, e::Ensemble, itr, itr)\n\nreturn the change in the offdiagonal many body matrix element of the interaction operator given by adding the kinks in the first iterable and removing the kinks in the second iterable\n\nboth arguments itr are required to be iterables containing kinks\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.τ_borders-Union{Tuple{T}, Tuple{Array{Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}},1},Any,Fixed{Int64,60}}} where T<:Orbital","page":"API reference","title":"CPIMC.τ_borders","text":" τ_borders(::Kinks{T}, orbs, ::ImgTime) where {T <: Orbital}\n\nReturn a tuple of the ImgTime of the closest kink to the right and the ImgTime of the closest kink to the left of τ that affect one of the orbitals in orbs. If no orbital in os is affected by and kink from the collection in the first argument, return a tuple of the interval bounds (ImgTime(0), ImgTime(1)).\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.τ_next_affecting-Tuple{Any,Any,Any}","page":"API reference","title":"CPIMC.τ_next_affecting","text":" τ_next_affecting(::Any, ::Any, ::Any)\n\nReturn the ImgTime of the closest kink to the right of τ that affects one of the orbitals in os.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.τ_prev_affecting-Tuple{Any,Any,Any}","page":"API reference","title":"CPIMC.τ_prev_affecting","text":" τ_prev_affecting(::Any, ::Any, ::Any)\n\nReturn the ImgTime of the closest kink to the left of τ that affects one of the orbitals in os.\n\n\n\n\n\n","category":"method"},{"location":"api/#Estimators","page":"API reference","title":"Estimators","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [CPIMC.Estimators]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"api/#CPIMC.Estimators.E-Tuple{Model,Ensemble,Configuration}","page":"API reference","title":"CPIMC.Estimators.E","text":"E(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the interaction energy This estimator is redundant because we can calculate the full energy as the sum of the kinetic and the interaction part.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.Estimators.Ekin-Tuple{Model,Ensemble,Configuration}","page":"API reference","title":"CPIMC.Estimators.Ekin","text":"Ekin(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the kinetic energy\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.Estimators.K-Tuple{Model,Ensemble,Configuration}","page":"API reference","title":"CPIMC.Estimators.K","text":"K(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the number of kinks\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.Estimators.W-Tuple{Model,Ensemble,Configuration}","page":"API reference","title":"CPIMC.Estimators.W","text":"W(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the interaction energy This estimator is redundant because we can calculate the interaction energy from Kfermion and Wdiag.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.Estimators.W_diag-Tuple{Model,Ensemble,Configuration}","page":"API reference","title":"CPIMC.Estimators.W_diag","text":"W_diag(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the diagonal contribution to the interaction energy\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.Estimators.W_off_diag-Tuple{Model,Ensemble,Configuration}","page":"API reference","title":"CPIMC.Estimators.W_off_diag","text":"W_off_diag(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the offdiagonal contribution to the interaction energy This estimator is redundant because we can calculate the offdiagonal interaction energy from K_fermion.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.Estimators.occupations","page":"API reference","title":"CPIMC.Estimators.occupations","text":"occupations(m::Model, e::Ensemble, c::Configuration, emax::Int=100) :: Array{Float64,1}\n\nestimator for the occupations of the emax:Int lowest single particle energy eigenvalues\n\n\n\n\n\n","category":"function"},{"location":"api/#CPIMC.signum-Tuple{Model,Ensemble,Configuration}","page":"API reference","title":"CPIMC.signum","text":"signum(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the sign of the weight function\n\n\n\n\n\n","category":"method"},{"location":"api/#PlaneWaves","page":"API reference","title":"PlaneWaves","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [CPIMC.PlaneWaves]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"api/#CPIMC.PlaneWaves.dimension-Union{Tuple{CPIMC.PlaneWaves.PlaneWave{D}}, Tuple{D}} where D","page":"API reference","title":"CPIMC.PlaneWaves.dimension","text":"dimension(o::PlaneWave{D}) where {D}\n\nreturn the dimension of the momentum vector of an Orbital\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.dimension-Union{Tuple{Set{#s16} where #s16<:CPIMC.PlaneWaves.PlaneWave{D}}, Tuple{D}} where D","page":"API reference","title":"CPIMC.PlaneWaves.dimension","text":"dimension(os::Set{<:PlaneWave{D}}) where {D}\n\nreturn the dimension of the momentum vectors of a Set{<:Orbital{D}}\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.find_fourth_orb_for_kink-Tuple{Any,Any,Any}","page":"API reference","title":"CPIMC.PlaneWaves.find_fourth_orb_for_kink","text":"find_fourth_orb_for_kink(same_kind_ladder_operator, other_kind_ladder_operator1, other_kind_ladder_operator2)\n\nFind the fourth orb to build a Kink accoring to spin/momentum conservation, where the Operator thats acts on the fourth orb is of the same kind (creator/ annihilator) as the one that acts on samekindladderoperator, While on otherkindladderoperator1 and otherkindladder_operator2 the other kind of operators will act.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.flip-Tuple{CPIMC.PlaneWaves.PlaneWave}","page":"API reference","title":"CPIMC.PlaneWaves.flip","text":"flip(o::PlaneWave)\n\nreturn an PlaneWave with the same momentum vector but opposite spin projection as the given o::PlaneWave \n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.flip-Tuple{CPIMC.PlaneWaves.Spin}","page":"API reference","title":"CPIMC.PlaneWaves.flip","text":"flip(s::Spin)\n\nreturn opposite spin projection\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.fractional_spin_polarization-Tuple{Configuration{#s16} where #s16<:CPIMC.PlaneWaves.PlaneWave}","page":"API reference","title":"CPIMC.PlaneWaves.fractional_spin_polarization","text":"fractional_spin_polarization(c::Configuration{<:PlaneWave})\n\ncalculate the fractional spin polarization from a set of Orbitals which each must have a field spin of type @enum Spin Down Up, the fractional spin polarization is defined as the ratio of the absolute difference of the number of particles which Spin Down and Spin Up and the particle number, thus here no convention is made as to which spin component should be occupied more often, as opposed to some literature where N↑ > N↓ is used\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.fractional_spin_polarization-Tuple{Set{#s16} where #s16<:CPIMC.PlaneWaves.PlaneWave}","page":"API reference","title":"CPIMC.PlaneWaves.fractional_spin_polarization","text":"fractional_spin_polarization(occ::Set{PlaneWave)\n\ncalculate the fractional spin polarization from a set of Orbitals which each must have a field spin of type @enum Spin Down Up, the fractional spin polarization is defined as the ratio of the absolute difference of the number of particles which Spin Down and Spin Up and the particle number, thus here no convention is made as to which spin component should be occupied more often, as opposed to some literature where N↑ > N↓ is used\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.sphere-Tuple{CPIMC.PlaneWaves.PlaneWave}","page":"API reference","title":"CPIMC.PlaneWaves.sphere","text":"sphere(o::PlaneWave{1}; dk=2)\nsphere(o::PlaneWave{2}; dk=2)\nsphere(o::PlaneWave{3}; dk=2)\n\nReturn the set of all PlaneWaves in a sphere of radius dk around o in momentum space.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.sphere_with_same_spin-Tuple{CPIMC.PlaneWaves.PlaneWave{1}}","page":"API reference","title":"CPIMC.PlaneWaves.sphere_with_same_spin","text":"sphere_with_same_spin(o::PlaneWave{1}; dk=2)\nsphere_with_same_spin(o::PlaneWave{2}; dk=2)\nsphere_with_same_spin(o::PlaneWave{3}; dk=2)\n\nReturn the set of all PlaneWaves in a sphere of radius dk around o in momentum space that also have the same spin as o.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.ξ-Tuple{Configuration{#s16} where #s16<:CPIMC.PlaneWaves.PlaneWave}","page":"API reference","title":"CPIMC.PlaneWaves.ξ","text":"ξ(c::Configuration{<:PlaneWave})\n\ncalculate the fractional spin polarization from a set of Orbitals which each must have a field spin of type @enum Spin Down Up, the fractional spin polarization is defined as the ratio of the absolute difference of the number of particles which Spin Down and Spin Up and the particle number, thus here no convention is made as to which spin component should be occupied more often, as opposed to some literature where N↑ > N↓ is used\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.ξ-Tuple{Set{#s16} where #s16<:CPIMC.PlaneWaves.PlaneWave}","page":"API reference","title":"CPIMC.PlaneWaves.ξ","text":"ξ(occ::Set{PlaneWave})\n\ncalculate the fractional spin polarization from a set of Orbitals which each must have a field spin of type @enum Spin Down Up, the fractional spin polarization is defined as the ratio of the absolute difference of the number of particles which Spin Down and Spin Up and the particle number, thus here no convention is made as to which spin component should be occupied more often, as opposed to some literature where N↑ > N↓ is used\n\n\n\n\n\n","category":"method"},{"location":"api/#UniformElectronGas","page":"API reference","title":"UniformElectronGas","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [CPIMC.UniformElectronGas]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"api/#CPIMC.UniformElectronGas.EF-Tuple{Any,Any,Int64}","page":"API reference","title":"CPIMC.UniformElectronGas.EF","text":"EF(rs, ξ, d::Int)\n\ncalculate the Fermi energy in Hartree a.u. from Brueckner parameter rs for the density, the fractional spin polarization ξ and spatial dimension d\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.UniformElectronGas.internal_energy_factor-Tuple{Any,Any,Any}","page":"API reference","title":"CPIMC.UniformElectronGas.internal_energy_factor","text":"internal_energy_factor(N, rs, d)\n\nThis factor is used to convert an energy quantity from Hartree a.u. to internal units. A value of the quantity in Hartree a.u. has to be multiplied by this factor to yield the corresponding value of the quantity in internal units. A value of the quantity in internal units has to be divided by this factor to yield the corresponding value of the quantity in Hartree a.u.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.UniformElectronGas.kF-Tuple{Any,Any,Int64}","page":"API reference","title":"CPIMC.UniformElectronGas.kF","text":"kF(rs, ξ, d::Int)\n\ncalculate the Fermi wavenumber in Hartree a.u. from Brueckner parameter rs for the density, the fractional spin polarization ξ and spatial dimension d\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.UniformElectronGas.rs-Tuple{Any,Any,Int64}","page":"API reference","title":"CPIMC.UniformElectronGas.rs","text":"rs(N, λ, d::Int)\n\ncalculate the Brueckner parameter rs for the density from the particle number N and λ, which is the coupling constant of the Hamiltonian in internal units\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.UniformElectronGas.β-Tuple{Any,Any,Any,Int64}","page":"API reference","title":"CPIMC.UniformElectronGas.β","text":"β(Θ, rs, N, ξ, d::Int)\n\ncalculate β in internal units\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.UniformElectronGas.β_Ha-Tuple{Any,Any}","page":"API reference","title":"CPIMC.UniformElectronGas.β_Ha","text":"β_Ha(Θ, EF)\n\ncalculate the inverse temperature in Hartree a.u. from the reduced temperature Θ and the Fermi energy EF in Hartree a.u. the inverse temperature is defined by β = 1 / (kB*T) where kB is the Boltzmann constant and T is the temperature\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.UniformElectronGas.λ-Tuple{Any,Any,Int64}","page":"API reference","title":"CPIMC.UniformElectronGas.λ","text":"λ(N, rs, d::Int)\n\ncalculate λ, which is the coupling constant of the Hamiltonian in internal units from the particle number N, Bruecker parameter rs for the density and spatial dimension d the differences for d ∈ {2,3} reflect the different expressions for the Coulomb interaction, whichs Fourier component is vq = \frac{4π}{q^2} in 3D and vq = \frac{2π}{q} in 2D the one-dimensional case involves a short-distance cutoff to avoid the non-integrable divergence of the interaction at zero distance and is not implemented\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.energy-Tuple{CPIMC.UniformElectronGas.UEG,CPIMC.PlaneWaves.PlaneWave}","page":"API reference","title":"CPIMC.energy","text":"energy(m::UEG, o::PlaneWave)\n\nThe single-particle energy of a plane wave with momentum veck is given by (Hartree atomic units):\n\n$ \\epsilon_k = \\vec{k}^2 / 2. $\n\nIn the internal unit system we use integer k-values, which results in:\n\n$ \\epsilon_k = \\vec{k}^2. $\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.w-Tuple{CPIMC.UniformElectronGas.UEG,Orbital,Orbital,Orbital,Orbital}","page":"API reference","title":"CPIMC.w","text":"w(i::Orbital, j::Orbital, k::Orbital, l::Orbital)\n\nReturn the two-particle matrix element of the Coulomb interaction. Zero is returned if momentum or spin is not conserved, in consequence of the Bloch-theorem and the spin kronecker-delta in the plane-spin-wave basis.\n\nThe singular contribution (i.vec == k.vec) is also removed, i.e. set to zero. This property is not a result of the Bloch theorem for the two-particle Coulomb matrix element in the plane wave basis but is added here to allow for straightforward summation over all combination of orbitals without explictly excluding this component.\n\nIt is not part of the UEG many-body Hamiltonian due to the physical assumption that contributions from the uniform background cancel with this diverging term in the thermodynamic limit.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Overview","page":"Manual","title":"Overview","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"This package provides a collection of types and routines for realizing path-integral Monte Carlo procedures in occupation number representation. In particular, one samples many-particle trajectories in imaginary time which are represented by the type Configuration{T}.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"It is given the set of orbitals occupied at tau = 0, and a collection of one- and two-particle excitations and their respective imaginary times. The type used for representing single-particle basis states is arbitrary and corresponds to the type variable T.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"One generally needs two kinds of functions:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Updates, which propose changes to a Configuration, thus providing the building blocks of the Markov chain.\nEstimators, which give the contribution of a particular Configuration to an expectation value.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The Monte Carlo process is carried out by the function sweep!, which generates the Markov chain from which the expectation values are calculated.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"A many-particle model is specified by the one- and two-particle matrix elements epsilon_ij and w_ijkl with respect to the chosen basis. These can be used to calculate the weight changes for the acceptance probability.","category":"page"},{"location":"#CPIMC2020","page":"Home","title":"CPIMC2020","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"New implementation of Configuration path-integral Monte Carlo (CPIMC) written in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Compared to other implementations we put particular emphasis on flexibility. The goal of this project is to provide an environment for trying out new ideas that is both easy to use and extend.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"full CPIMC simulation for the uniform electron gas using a plane waves basis\nno artificial restriction on the number of basis functions\nno explicit ordering of orbitals required\nmulti-threading","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A full description of the formalism can be found in Tim Schoof's PhD thesis[1]. For a more modern perspective which is closer to this implementation one should also consider Kai Hunger's Master thesis [WIP].","category":"page"},{"location":"","page":"Home","title":"Home","text":"As a gentle introduction we prepared an implementation of the ideal Fermi gas in examples/ideal.jl which should get you accustomed to the core functionality of this package. This should prepare you to explore on your own how the model of the uniform electron gas is realized in src/UniformElectronGas.jl.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Schoof, T. (2016). Configuration Path Integral Monte Carlo: Ab initio simulations of fermions in the warm dense matter regime [PhD thesis, CAU Kiel] https://d-nb.info/1133492177/34","category":"page"}]
}

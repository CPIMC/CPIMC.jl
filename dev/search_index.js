var documenterSearchIndex = {"docs":
[{"location":"api/#CPIMC","page":"API reference","title":"CPIMC","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [CPIMC]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"api/#Base.getindex-Union{Tuple{T}, Tuple{Array{Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}},1},Fixed{Int64,60}}} where T","page":"API reference","title":"Base.getindex","text":"Base.getindex(kinks::Kinks{T}, τ::ImgTime) where {T}\n\nAllow the kinks[τ]-syntax to retrieve a Kink at a specific ImgTime.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey-Tuple{Array{Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}},1} where T,Fixed{Int64,60}}","page":"API reference","title":"Base.haskey","text":"Base.haskey(ck::Kinks, key::ImgTime)\n\nCheck if a Kinks-object contains a kink at a specific time.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.apply_step!-Tuple{Configuration,Step}","page":"API reference","title":"CPIMC.apply_step!","text":"apply_step!(c::Configuration, step::Step)\napply_step!(c::Configuration, steps)\n\nApply the changes given by the second argument to a Configuration.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.apply_step-Tuple{Configuration,Any}","page":"API reference","title":"CPIMC.apply_step","text":"apply_step(c::Configuration, step::Step)\napply_step(c::Configuration, steps)\n\nReturn the result of applying the changes given by the second argument to a Configuration.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.excitations-Tuple{Array{Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}},1} where T}","page":"API reference","title":"CPIMC.excitations","text":"excitations(ck::Kinks)\n\nReturn a list of the excitations of a Kinks-object, used to allow the use of dictionary syntax.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.excite!-Union{Tuple{T}, Tuple{Set{T},T,T,T,T}} where T","page":"API reference","title":"CPIMC.excite!","text":"excite!(::Set{T}, i::T, j::T, k::T, l::T) where {T}\nexcite!(o::Set{T}, κ::T4{T})\n\nApply an excitation in-place to a set of basis states that is given by creating orbitals i, j and annihilating the orbitals k, l.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.excite-Union{Tuple{T}, Tuple{Set{T},Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}}}} where T","page":"API reference","title":"CPIMC.excite","text":"excite(o::Set{T}, κ::Pair{ImgTime,T4{T}})\n\nApply a T4-kink to a set of basis states for a pair of a time and a T4-kink. This is useful for iterating over a Kinks-object when calculating the occupations at a specific time.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.excite-Union{Tuple{T}, Tuple{Set{T},T4{T}}} where T","page":"API reference","title":"CPIMC.excite","text":"excite(::Set{T}, ::T4{T})\n\nApply a kink to a set of basis states, i.e. return a set of basis states where the states specified by the creators of the kink are added and the states specified by the annihilators of the kink are dropped from the given set of basis states. This has the physical meaning of a two-particle scattering event where two (quasi-)particles in a many-body state change the single-particle states they occupy. In occupation number representation this reads\n\na^dagger_i a^dagger_j a_k a_l nrangle\n\nfor creator orbitals i and j and annihilator orbitals k and l. This function assumes fermionic particle statistics (Pauli principle),\n\na^dagger_i a^dagger_i = a_i a_i = 0\n\ni.e. the target (creator) states must not be occupied and the initial (annihilator) states must be occupied in the given set of states.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.measure!-NTuple{4,Any}","page":"API reference","title":"CPIMC.measure!","text":"measure!(m::Model, e::Ensemble, c::Configuration, estimators)\n\nPerform measurements on a Configuration. estimators needs to be a dictionary that contains tuples (::OnlineStat, ::Function).\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.print_rates-Tuple{Any}","page":"API reference","title":"CPIMC.print_rates","text":"print_rates(dict::Dict{Any,UpdateCounter})\n\nCalculate and print acceptance statistics.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.print_results-Tuple{Any,Ensemble}","page":"API reference","title":"CPIMC.print_results","text":"print_results(measurements, e::Ensemble)\n\nPrint all measured observables, potentially taking the sign into account.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.sweep!-Tuple{Model,Ensemble,Configuration,Any,Any,Int64,Int64,Int64}","page":"API reference","title":"CPIMC.sweep!","text":"sweep!(m::Model, e::Ensemble, c::Configuration, updates, estimators, steps::Int, sampleEvery::Int, throwAway::Int)\n\nGenerate a markov chain of length steps using the Metropolis-Hastings algorithm with the updates given in updates. After throwAway steps have been performed, the observables given in estimators are calculated every sampleEvery steps.\n\nReturns a dictionary containing an UpdateCounter for every function given in updates.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.times-Tuple{Array{Pair{Fixed{Int64,60},Union{T2{T}, T4{T}}},1} where T}","page":"API reference","title":"CPIMC.times","text":"times(ck::Kinks)\n\nReturn a list of the imaginary-times of a Kinks-object, used to allow the use of dictionary syntax.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.update!-Tuple{Model,Ensemble,Configuration,Any}","page":"API reference","title":"CPIMC.update!","text":"update!(m::Model, e::Ensemble, c::Configuration, updates)\n\nObtain the next state of the Markov chain by randomly selecting an element of updates and applying the proposed changes to c with the calculated probability. Returns a tuple containing the index of the chosen function and :accept, :reject or :trivial if the function yielded an empty Step.\n\n\n\n\n\n","category":"method"},{"location":"api/#Estimators","page":"API reference","title":"Estimators","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [CPIMC.Estimators]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"api/#CPIMC.Estimators.E-Tuple{Model,Ensemble,Configuration}","page":"API reference","title":"CPIMC.Estimators.E","text":"E(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the interaction energy This estimator is redundant because we can calculate the full energy as the sum of the kinetic and the interaction part.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.Estimators.Ekin-Tuple{Model,Ensemble,Configuration}","page":"API reference","title":"CPIMC.Estimators.Ekin","text":"Ekin(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the kinetic energy\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.Estimators.K-Tuple{Model,Ensemble,Configuration}","page":"API reference","title":"CPIMC.Estimators.K","text":"K(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the number of kinks\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.Estimators.W-Tuple{Model,Ensemble,Configuration}","page":"API reference","title":"CPIMC.Estimators.W","text":"W(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the interaction energy This estimator is redundant because we can calculate the interaction energy from Kfermion and Wdiag.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.Estimators.W_diag-Tuple{Model,Ensemble,Configuration}","page":"API reference","title":"CPIMC.Estimators.W_diag","text":"W_diag(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the diagonal contribution to the interaction energy\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.Estimators.W_off_diag-Tuple{Model,Ensemble,Configuration}","page":"API reference","title":"CPIMC.Estimators.W_off_diag","text":"W_off_diag(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the offdiagonal contribution to the interaction energy This estimator is redundant because we can calculate the offdiagonal interaction energy from K_fermion.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.Estimators.occupations","page":"API reference","title":"CPIMC.Estimators.occupations","text":"occupations(m::Model, e::Ensemble, c::Configuration, emax::Int=100) :: Array{Float64,1}\n\nestimator for the occupations of the emax:Int lowest single particle energy eigenvalues\n\n\n\n\n\n","category":"function"},{"location":"api/#CPIMC.signum-Tuple{Model,Ensemble,Configuration}","page":"API reference","title":"CPIMC.signum","text":"signum(m::Model, e::Ensemble, c::Configuration)\n\nestimator for the sign of the weight function\n\n\n\n\n\n","category":"method"},{"location":"api/#PlaneWaves","page":"API reference","title":"PlaneWaves","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [CPIMC.PlaneWaves]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"api/#CPIMC.PlaneWaves.dimension-Union{Tuple{CPIMC.PlaneWaves.PlaneWave{D}}, Tuple{D}} where D","page":"API reference","title":"CPIMC.PlaneWaves.dimension","text":"dimension(o::PlaneWave{D}) where {D}\n\nreturn the dimension of the momentum vector of an Orbital\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.dimension-Union{Tuple{Set{#s16} where #s16<:CPIMC.PlaneWaves.PlaneWave{D}}, Tuple{D}} where D","page":"API reference","title":"CPIMC.PlaneWaves.dimension","text":"dimension(os::Set{<:PlaneWave{D}}) where {D}\n\nreturn the dimension of the momentum vectors of a Set{<:Orbital{D}}\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.find_fourth_orb_for_kink-Tuple{Any,Any,Any}","page":"API reference","title":"CPIMC.PlaneWaves.find_fourth_orb_for_kink","text":"find_fourth_orb_for_kink(same_kind_ladder_operator, other_kind_ladder_operator1, other_kind_ladder_operator2)\n\nFind the fourth orb to build a Kink accoring to spin/momentum conservation, where the Operator thats acts on the fourth orb is of the same kind (creator/ annihilator) as the one that acts on samekindladderoperator, While on otherkindladderoperator1 and otherkindladder_operator2 the other kind of operators will act.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.flip-Tuple{CPIMC.PlaneWaves.PlaneWave}","page":"API reference","title":"CPIMC.PlaneWaves.flip","text":"flip(o::PlaneWave)\n\nreturn an PlaneWave with the same momentum vector but opposite spin projection as the given o::PlaneWave \n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.flip-Tuple{CPIMC.PlaneWaves.Spin}","page":"API reference","title":"CPIMC.PlaneWaves.flip","text":"flip(s::Spin)\n\nreturn opposite spin projection\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.fractional_spin_polarization-Tuple{Configuration{#s16} where #s16<:CPIMC.PlaneWaves.PlaneWave}","page":"API reference","title":"CPIMC.PlaneWaves.fractional_spin_polarization","text":"fractional_spin_polarization(c::Configuration{<:PlaneWave})\n\ncalculate the fractional spin polarization from a set of Orbitals which each must have a field spin of type @enum Spin Down Up, the fractional spin polarization is defined as the ratio of the absolute difference of the number of particles which Spin Down and Spin Up and the particle number, thus here no convention is made as to which spin component should be occupied more often, as opposed to some literature where N↑ > N↓ is used\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.fractional_spin_polarization-Tuple{Set{#s16} where #s16<:CPIMC.PlaneWaves.PlaneWave}","page":"API reference","title":"CPIMC.PlaneWaves.fractional_spin_polarization","text":"fractional_spin_polarization(occ::Set{PlaneWave)\n\ncalculate the fractional spin polarization from a set of Orbitals which each must have a field spin of type @enum Spin Down Up, the fractional spin polarization is defined as the ratio of the absolute difference of the number of particles which Spin Down and Spin Up and the particle number, thus here no convention is made as to which spin component should be occupied more often, as opposed to some literature where N↑ > N↓ is used\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.sphere-Tuple{CPIMC.PlaneWaves.PlaneWave}","page":"API reference","title":"CPIMC.PlaneWaves.sphere","text":"sphere(o::PlaneWave{1}; dk=2)\nsphere(o::PlaneWave{2}; dk=2)\nsphere(o::PlaneWave{3}; dk=2)\n\nReturn the set of all PlaneWaves in a sphere of radius dk around o in momentum space.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.sphere_with_same_spin-Tuple{CPIMC.PlaneWaves.PlaneWave{1}}","page":"API reference","title":"CPIMC.PlaneWaves.sphere_with_same_spin","text":"sphere_with_same_spin(o::PlaneWave{1}; dk=2)\nsphere_with_same_spin(o::PlaneWave{2}; dk=2)\nsphere_with_same_spin(o::PlaneWave{3}; dk=2)\n\nReturn the set of all PlaneWaves in a sphere of radius dk around o in momentum space that also have the same spin as o.\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.ξ-Tuple{Configuration{#s16} where #s16<:CPIMC.PlaneWaves.PlaneWave}","page":"API reference","title":"CPIMC.PlaneWaves.ξ","text":"ξ(c::Configuration{<:PlaneWave})\n\ncalculate the fractional spin polarization from a set of Orbitals which each must have a field spin of type @enum Spin Down Up, the fractional spin polarization is defined as the ratio of the absolute difference of the number of particles which Spin Down and Spin Up and the particle number, thus here no convention is made as to which spin component should be occupied more often, as opposed to some literature where N↑ > N↓ is used\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.PlaneWaves.ξ-Tuple{Set{#s16} where #s16<:CPIMC.PlaneWaves.PlaneWave}","page":"API reference","title":"CPIMC.PlaneWaves.ξ","text":"ξ(occ::Set{PlaneWave})\n\ncalculate the fractional spin polarization from a set of Orbitals which each must have a field spin of type @enum Spin Down Up, the fractional spin polarization is defined as the ratio of the absolute difference of the number of particles which Spin Down and Spin Up and the particle number, thus here no convention is made as to which spin component should be occupied more often, as opposed to some literature where N↑ > N↓ is used\n\n\n\n\n\n","category":"method"},{"location":"api/#UniformElectronGas","page":"API reference","title":"UniformElectronGas","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [CPIMC.UniformElectronGas]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"api/#CPIMC.UniformElectronGas.EF-Tuple{Any,Any,Int64}","page":"API reference","title":"CPIMC.UniformElectronGas.EF","text":"EF(rs, ξ, d::Int)\n\ncalculate the Fermi energy in Hartree a.u. from Brueckner parameter rs for the density, the fractional spin polarization ξ and spatial dimension d\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.UniformElectronGas.kF-Tuple{Any,Any,Int64}","page":"API reference","title":"CPIMC.UniformElectronGas.kF","text":"kF(rs, ξ, d::Int)\n\ncalculate the Fermi wavenumber in Hartree a.u. from Brueckner parameter rs for the density, the fractional spin polarization ξ and spatial dimension d\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.UniformElectronGas.rs-Tuple{Any,Any,Int64}","page":"API reference","title":"CPIMC.UniformElectronGas.rs","text":"rs(N, λ, d::Int)\n\ncalculate the Brueckner parameter rs for the density from the particle number N and λ, which is the coupling constant of the Hamiltonian in internal units\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.UniformElectronGas.β-Tuple{Any,Any,Any,Int64}","page":"API reference","title":"CPIMC.UniformElectronGas.β","text":"β(Θ, rs, N, ξ, d::Int)\n\ncalculate β in internal units\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.UniformElectronGas.β_Ha-Tuple{Any,Any}","page":"API reference","title":"CPIMC.UniformElectronGas.β_Ha","text":"β_Ha(Θ, EF)\n\ncalculate the inverse temperature in Hartree a.u. from the reduced temperature Θ and the Fermi energy EF in Hartree a.u. the inverse temperature is defined by β = 1 / (kB*T) where kB is the Boltzmann constant and T is the temperature\n\n\n\n\n\n","category":"method"},{"location":"api/#CPIMC.UniformElectronGas.λ-Tuple{Any,Any,Int64}","page":"API reference","title":"CPIMC.UniformElectronGas.λ","text":"λ(N, rs, d::Int)\n\ncalculate λ, which is the coupling constant of the Hamiltonian in internal units from the particle number N, Bruecker parameter rs for the density and spatial dimension d the differences for d ∈ {2,3} reflect the different expressions for the Coulomb interaction, whichs Fourier component is vq = \frac{4π}{q^2} in 3D and vq = \frac{2π}{q} in 2D the one-dimensional case involves a short-distance cutoff to avoid the non-integrable divergence of the interaction at zero distance and is not implemented\n\n\n\n\n\n","category":"method"},{"location":"manual/#Overview","page":"Manual","title":"Overview","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"This package provides a collection of types and routines for realizing path-integral Monte Carlo procedures in occupation number representation. In particular, one samples many-particle trajectories in imaginary time which are represented by the type Configuration{T}.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"It is given the set of orbitals occupied at tau = 0, and a collection of one- and two-particle excitations and their respective imaginary times. The type used for representing single-particle basis states is arbitrary and corresponds to the type variable T.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"One generally needs two kinds of functions:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Updates, which propose changes to a Configuration, thus providing the building blocks of the Markov chain.\nEstimators, which give the contribution of a particular Configuration to an expectation value.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The Monte Carlo process is carried out by the function sweep!, which generates the Markov chain from which the expectation values are calculated.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"A many-particle model is specified by the one- and two-particle matrix elements epsilon_ij and w_ijkl with respect to the chosen basis. These can be used to calculate the weight changes for the acceptance probability.","category":"page"},{"location":"#CPIMC2020","page":"Home","title":"CPIMC2020","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"New implementation of Configuration path-integral Monte Carlo (CPIMC) written in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Compared to other implementations we put particular emphasis on flexibility. The goal of this project is to provide an environment for trying out new ideas that is both easy to use and extend.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"full CPIMC simulation for the uniform electron gas using a plane waves basis\nno artificial restriction on the number of basis functions\nno explicit ordering of orbitals required\nmulti-threading","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A full description of the formalism can be found in Tim Schoof's PhD thesis[1]. For a more modern perspective which is closer to this implementation one should also consider Kai Hunger's Master thesis [WIP].","category":"page"},{"location":"","page":"Home","title":"Home","text":"As a gentle introduction we prepared an implementation of the ideal Fermi gas in examples/ideal.jl which should get you accustomed to the core functionality of this package. This should prepare you to explore on your own how the model of the uniform electron gas is realized in src/UniformElectronGas.jl.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Schoof, T. (2016). Configuration Path Integral Monte Carlo: Ab initio simulations of fermions in the warm dense matter regime [PhD thesis, CAU Kiel] https://d-nb.info/1133492177/34","category":"page"}]
}
